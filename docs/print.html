<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Guide to Project Euler in Scala</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Project Euler in Scala</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-guide"><a class="header" href="#about-this-guide">About this guide</a></h1>
<p>This guide contains solutions for the first 100 problems from the Project Euler website.
Full code, in a form of runnable classes, is available on GitHub: https://github.com/Detharon/ProjectEuler</p>
<p>The code is shared for educational purposes, demonstrating how these problems can be approached using Scala.
There are many other sites that discuss Project Euler problems, but here, the purpose it twofold:
discuss the problem while emphasizing Scala's strengths of making efficient code that's easy to understand.</p>
<p>So, whenever possible, a functional programming style is used, avoiding mutable state and vars. Some solutions
intentionally deviate from this approach for performance comparison;
these are marked with an ‘M’ suffix in their filenames.</p>
<p>While the non-functional style may yield greater efficiency by reducing object allocations, it often results in less
readable and more error-prone code, so it is included primarily for contrast and learning purposes.</p>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to use this guide</a></h2>
<p>My advice would be to read the solutions only when you've already solved the problem. It's normal to struggle at the
beginning. The first solution can be unoptimized and too slow to give the final result, but it's a good starting
point to think what can be improved.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Even though it's an individual work, that's heavily influenced by my personal style, I'm open for contributions.
If you want to add your some extra insights, you've found an error or a mistake, please send a pull request
or raise an issue in GitHub.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project status</a></h2>
<p>The project it still in progress, with many problems missing.
Some of them are solved but not described yet in this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-solutions"><a class="header" href="#problem-solutions">Problem solutions</a></h1>
<p>You can find the code for all the problems in the project repository, in <code>src/main/scala</code> directory.
All examples are runnable, and they only print the solution, along the execution time.</p>
<p>A commonly used code can be found in <code>EulerHelper</code> class, but other than that, the solutions are self-contained.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiples-of-3-or-5"><a class="header" href="#multiples-of-3-or-5">Multiples of 3 or 5</a></h1>
<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these
multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>The only tricky part of this exercise comes from the fact that we cannot simply count the multiplies of 3,
then calculate the multiplies of 5, and add these two numbers up. If we did that, then the numbers that are divisible
by both 3 and 5 would be calculated twice.</p>
<p>In this solution, we create three sets of numbers. If a number of divisible by both 3 and 5, then it's divisible by 15,
so we can find those numbers and subtract them from the two other sets.</p>
<pre><code class="language-scala">object Euler001 extends EulerApp {
  override def execute(): Int = {
    val threes = (3 until 1000 by 3).sum
    val fives = (5 until 1000 by 5).sum
    val fifteens = (15 until 1000 by 15).sum

    threes + fives - fifteens
  }
}
</code></pre>
<p>The problem can be also solved by checking all the numbers to see if they're divisible by 3 or 5.
Shorter, nothing gets counted twice, but you may find it harder to read.</p>
<pre><code class="language-scala">(3 until 1000).filter(n =&gt; n % 3 == 0 || n % 5 == 0).sum
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fibonacci-numbers"><a class="header" href="#even-fibonacci-numbers">Even Fibonacci Numbers</a></h1>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.</p>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<p>The numbers are small enough to calculate it in a matter of milliseconds without any optimisations.
Fibonacci implementation is done with a LazyList to make it infinite. Is this an efficient approach?
Not really, because <code>LazyList</code> memoizes all the elements, but we need just the previous 2.</p>
<p>In this case, due to how easy this task is, let's keep it as it is.</p>
<pre><code class="language-scala">object Euler002 extends EulerApp {
  override def execute(): Int =
    fibonacci.filter(_ % 2 == 0).takeWhile(_ &lt; 4_000_000).sum

  val fibonacci: LazyList[Int] = 1 #:: fibonacciFunction(1, 2)

  private def fibonacciFunction(a: Int, b: Int): LazyList[Int] =
    a #:: fibonacciFunction(b, a + b)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-prime-factor"><a class="header" href="#largest-prime-factor">Largest Prime Factor</a></h1>
<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
<p>What is the largest prime factor of the number 600851475143?</p>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<p>Before implementing anything, let's think how finding the prime factors works.
Let's consider the number from the description, 13195. We can just try all the numbers until we hit a prime, then
check if it's divisible by this prime. Once we found a factor, we can just divide the original number by it.</p>
<p>So, the 13195 turns into 13195 / 5 = 2639.</p>
<p>Then 2639 / 7 = 377.</p>
<p>Then 377 / 13 = 29.</p>
<p>And finally 29 / 29 = 1.</p>
<p>In fact, we could check each result to see if it's a prime, because if it is, then we know that we've found
the biggest prime factor and can just return it.</p>
<p>But there are some reasons not to do that as well. Let's take a look at a complete solution, without that final
optimization:</p>
<pre><code class="language-scala">import EulerHelper.naiveIsPrime

import scala.annotation.tailrec

object Euler003 extends EulerApp {
  override def execute(): Long = primeFactors(600851475143L).max

  @tailrec
  private def primeFactors(n: Long, i: Int = 2, primesFound: List[Int] = List.empty): List[Int] =
    if (n == 1) primesFound
    else if (n % i == 0 &amp;&amp; naiveIsPrime(i)) primeFactors(n / i, i + 1, primesFound :+ i)
    else primeFactors(n, i + 1, primesFound)
}
</code></pre>
<p>The prime check is done in a naive way, by checking all the numbers. It's not efficient, and in the process we're
checking multiple numbers over and over again, but it's still blazing fast.
Now, the reason why the final optimization was not done, because it would make the app run much slower: doing the same
check on longs rather than integers, made the app run 5 times as long.</p>
<pre><code class="language-scala">  extension (n: Int) {
    def naiveIsPrime: Boolean = n match {
      case n if n &lt; 2 =&gt; false
      case _          =&gt; (2 to Math.sqrt(n.toDouble).toInt).forall(n % _ != 0)
    }
  }
</code></pre>
<p>In the end, it doesn't make sense to overly optimize such a simple problem.
Out solution solves it and is easy to understand, so let's move on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-palindrome-product"><a class="header" href="#largest-palindrome-product">Largest Palindrome Product</a></h1>
<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two
2-digit numbers is 9009 = 91 * 99</p>
<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<p>A brute-force solution would also work reasonably well, but we can actually reduce the number of numbers to be checked.</p>
<p>We know that multiplying two 3-digit numbers will give us a 6-digit number at most,
so the palindrome we're looking for has the "abccba" form, or: 100000a + 10000b + 1000c + 100c + 10b + a.</p>
<p>If we add those numbers we get "100001a + 10010b + 1100c".
We can then factor out 11, which means that our palindrome has to be divisible by 11: 11(9091a + 910b + 100c)</p>
<p>One of the numbers then has to be divisible by 11, because it's a prime number.
We can start from 990 instead of 999 and decrease the numbers checked by 11.</p>
<p>As for checking if a string is a palindrome, there are many ways to do that. It can be done iteratively, recursively,
or with built-in functions like here. Neither changes the run time, so it doesn't matter much for this problem.</p>
<pre><code class="language-scala">object Euler004 extends EulerApp {
  override def execute(): Int = (for {
    a &lt;- 990 to 100 by -11
    b &lt;- 999 to 100 by -1
  } yield a * b)
    .filter(n =&gt; isPalindrome(n.toString))
    .max

  def isPalindrome(s: String): Boolean = s == s.reverse
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smallest-multiple"><a class="header" href="#smallest-multiple">Smallest Multiple</a></h1>
<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>
<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p>
<h2 id="lets-make-it-easier"><a class="header" href="#lets-make-it-easier">Let's make it easier</a></h2>
<p>First, let's try to decrease a bit the number of numbers we'll need to check. We can analyze the simpler problem for
which we already know the answer.</p>
<p>The 2520 is divisible by all numbers from 1 to 10. We know that among those numbers, 2, 3, 5, 7 are primes. So, if the
number we're looking for is divisible by all these prime numbers, then it must be a multiple of (2 × 3 × 5 × 7) = 210.</p>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>We can follow the same logic to find a number that's evenly divisible by all numbers from 1 to 20.</p>
<p>Prime numbers in this set are: 2, 3, 5, 7, 11, 13, 17, 19. The number we're looking for, then, must be a multiple of
2 × 3 × 5 × 7 × 11 × 13 × 17 × 19 = 9699690.</p>
<p>Let's try to find that number!</p>
<pre><code class="language-scala">object Euler005 extends EulerApp {
  // 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690
  override def execute(): Int = Iterator
    .from(9699690, 9699690)
    .find { n =&gt;
      (2 to 20).forall(k =&gt; n % k == 0)
    }
    .get
}
</code></pre>
<p>If we wanted to improve it even further, then we can notice that we don't need to check again if our numbers are
divisible by all these prime numbers. Also, multiplies of these numbers, such as 6 (2 * 3), no need to be checked either.</p>
<p>That's because every number that's divisible by both 2 and 3 must be divisible by 6.</p>
<p>We don't need to make it more complex than necessary. The current solution already runs in 1-2 ms on my machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sum-square-difference"><a class="header" href="#sum-square-difference">Sum Square Difference</a></h1>
<p>The sum of the squares of the first ten natural numbers is,</p>
<p>\(1^2 + 2^2 + ... + 10^2 = 385\)</p>
<p>The square of the sum of the first ten natural numbers is,</p>
<p>\((1 + 2 + ... + 10)^2 = 55^2 = 3025\)</p>
<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is</p>
<p>\(3025 - 385 = 2640\)</p>
<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<p>It's a pretty straightforward problem. We can simply write down the problem literally, without any optimizations, and
we're good to go. Scala's expressiveness makes this task a breeze and the resulting code is easy to understand.</p>
<p>To make it extra concise, let's also define a "square" extension method.</p>
<pre><code class="language-scala">object Euler006 extends EulerApp {
  override def execute(): Int = squareOfSums(100) - sumOfSquares(100)

  private def sumOfSquares(n: Int) = (1 to n).map(_.square).sum

  private def squareOfSums(n: Int) = (1 to n).sum.square

  extension (i: Int) {
    def square: Int = i * i
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-001st-prime"><a class="header" href="#10-001st-prime">10 001st Prime</a></h1>
<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>
<p>What is the 10001st prime number?</p>
<h2 id="solution-6"><a class="header" href="#solution-6">Solution</a></h2>
<p>We can simply brute-force this problem by using the most naive prime check, since the 10001st prime will be a low
number. This solution is pretty fast, even though the algorithm is not very efficient.</p>
<p>As you can see, we don't even filter out even numbers higher than 2 (or all the multiplies of already found primes),
but we'll need these methods later on. For now, a basic algorithm does pretty well.</p>
<pre><code class="language-scala">import EulerHelper.naiveIsPrime

object Euler007 extends EulerApp {
  override def execute(): Any = Iterator
    .from(2)
    .filter(naiveIsPrime)
    .drop(10000)
    .next()
}
</code></pre>
<p>And for the reference, that's how we check if a number is a prime. A brute-force solution, that ran in 13 ms on my
machine, which is pretty good already.</p>
<pre><code class="language-scala">  extension (n: Int) {
    def naiveIsPrime: Boolean = n match {
      case n if n &lt; 2 =&gt; false
      case _          =&gt; (2 to Math.sqrt(n.toDouble).toInt).forall(n % _ != 0)
    }
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-series"><a class="header" href="#largest-product-in-a-series">Largest Product in a Series</a></h1>
<p>The four adjacent digits in the 1000-digit number that have the greatest product are</p>
<p>\(9 × 9 × 8 × 9 = 5832\)</p>
<p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p>
<h2 id="solution-7"><a class="header" href="#solution-7">Solution</a></h2>
<p>The number might look daunting, but for any algorithm it's small enough that we don't need to optimize it much.
This is the shortest solution (code-wise), but also the least efficient. We split the string into 13-element sliding windows,
then calculate the product of the digits in each window.</p>
<p>Once we have the list of products, we simply take the maximum. Easy-peasy.
Could you explain why this solution is inefficient and what could significantly improve it, even at the cost of no
longer being functional?</p>
<pre><code class="language-scala">object Euler008 extends EulerApp {
  override def execute(): Any = {
    val number = "73167176531330624919225119674426574742355349194934" +
      "96983520312774506326239578318016984801869478851843" +
      "85861560789112949495459501737958331952853208805511" +
      "12540698747158523863050715693290963295227443043557" +
      "66896648950445244523161731856403098711121722383113" +
      "62229893423380308135336276614282806444486645238749" +
      "30358907296290491560440772390713810515859307960866" +
      "70172427121883998797908792274921901699720888093776" +
      "65727333001053367881220235421809751254540594752243" +
      "52584907711670556013604839586446706324415722155397" +
      "53697817977846174064955149290862569321978468622482" +
      "83972241375657056057490261407972968652414535100474" +
      "82166370484403199890008895243450658541227588666881" +
      "16427171479924442928230863465674813919123162824586" +
      "17866458359124566529476545682848912883142607690042" +
      "24219022671055626321111109370544217506941658960408" +
      "07198403850962455444362981230987879927244284909188" +
      "84580156166097919133875499200524063689912560717606" +
      "05886116467109405077541002256983155200055935729725" +
      "71636269561882670428252483600823257530420752963450"

    number.sliding(13).map(_.map(_.asDigit.toLong).product).max
  }
}
</code></pre>
<h2 id="mutable-solution"><a class="header" href="#mutable-solution">Mutable solution</a></h2>
<p>In the earlier approach, the sliding windows were completely independent of one another, which made it immutable, but
as I've also mentioned -- pretty inefficient.</p>
<p>By calculating the product of 13 elements, we were performing 11 redundant multiplications in each neighboring window.</p>
<p>Instead, we can maintain a running product — dividing by the digit that leaves the window
and multiplying by the new digit that enters it. The only catch here are the zeroes that break the computation chain.</p>
<p>While this approach is definitely faster, it’s also more error-prone and harder to read.
For example, consider the following line:</p>
<pre><code class="language-scala">previous = buffer.remove(0).asDigit
</code></pre>
<p>It’s not immediately clear that <code>remove(0)</code> returns the element being removed.
Moreover, if the <code>.asDigit</code> call were omitted, the code would still compile and run,
but it would silently produce an incorrect result. For such a small task, the optimization is not worth
the effort, so treat it merely as a mental exercise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-pythagorean-triplet"><a class="header" href="#special-pythagorean-triplet">Special Pythagorean Triplet</a></h1>
<p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,</p>
<p>\(a^2 + b^2 = c^2\)</p>
<p>For example \(3^2 + 4^2 = 9 + 16 = 25 = 5^2\).</p>
<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.</p>
<p>Find the product abc.</p>
<h2 id="solution-8"><a class="header" href="#solution-8">Solution</a></h2>
<p>The numbers are low enough for a naive approach, so let's use it, while keeping the code nice and clean.</p>
<p>We need to check all combinations of a, b, c for which a + b + c = 1000 and find those that form a
Pythagorean triplet.</p>
<p>This naive algorithm starts from the highest possible 'c', keeps the sum of parameters at 1000, while gradually
incrementing 'b' and decrementing 'c' until this it's possible. This condition (b == c - 2 || b == c - 1) indicates
that the next triangle can't be created this way, so we need to increase the 'a' instead, while resetting the other
two parameters: 'b' to the lowest possible one, 'c' to whatever will give a sum of 1000.</p>
<p>It uses a LazyList which does keeps all the previous elements in memory. That's not something we need, but it makes
the code pretty concise. Let's also try a mutable approach.</p>
<pre><code class="language-scala">object Euler009 extends EulerApp {
  override def execute(): Any = {
    triangles.dropWhile(!isPythagorean(_)).head.product
  }

  type Triangle = (Int, Int, Int)
  val triangles: LazyList[Triangle] = triangles(1, 2, 997)

  private def triangles(a: Int, b: Int, c: Int): LazyList[Triangle] = {
    (a, b, c) #:: {
      if (b == c - 2 || b == c - 1) triangles(a + 1, a + 2, 997 - (2 * a))
      else triangles(a, b + 1, c - 1)
    }
  }

  private def isPythagorean(triangle: Triangle): Boolean = {
    val Triangle(a, b, c) = triangle
    a * a + b * b == c * c
  }

  extension (t: Triangle) {
    def product: Int = t._1 * t._2 * t._3
  }
}
</code></pre>
<h2 id="mutable-solution-1"><a class="header" href="#mutable-solution-1">Mutable solution</a></h2>
<p>This time let's aim for maximum efficiency. Even though the idiomatic solution found the solution pretty fast
on my machine, the optimized one is about 10 to 15 times faster, even though they share the same algorithm.</p>
<p>It's also more concise. It looks rather enigmatic, which is the usual pitfalls for the optimized solutions, but
in this case the difference in performance was quite substantial.</p>
<pre><code class="language-scala">object Euler009M extends EulerApp {
  override def execute(): Any = {
    var a = 1
    var b = 2
    var c = 997
    var found = false

    while (!found) {
      if (a * a + b * b == c * c) found = true
      else {
        if (b == c - 1 || b == c - 2) {
          a = a + 1
          b = a + 1
          c = 1000 - b - a
        } else {
          b = b + 1
          c = c - 1
        }
      }
    }

    a * b * c
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-of-primes"><a class="header" href="#summation-of-primes">Summation of Primes</a></h1>
<p>The sum of the primes below \(10\) is \(2 + 3 + 5 + 7 = 17\).</p>
<p>Find the sum of all the primes below two million.</p>
<h2 id="solution-9"><a class="header" href="#solution-9">Solution</a></h2>
<p>We could use the brute-force method to check all the numbers up to two million, one by one, to see if they're primes,
exactly how we did that before.</p>
<p>It would eventually finish, because we don't run out of memory, but we wouldn't learn anything useful this way.</p>
<p>This is the perfect problem to use the sieve of Eratosthenes. If you've never heard about it, then I
suggest looking it up, as it will be used in the future problems as
well: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</p>
<p>Unfortunately, the sieve itself doesn't go along well with immutable data structures because its creation is done
iteratively, by small incremental changes. This time I'll only present a mutable version.</p>
<p>In this solution, we're filling the sieve, which initially considers all numbers to be primes (true) and marks the
multiples of existing primes as non-primes (false). Once we hit next number, we know that if its factors were not
found already, then it's a prime. No need for any another check!</p>
<p>While filling the sieve, we'll also calculate the <code>primeSum</code> to avoid iterating the array again.
It makes it even more mutable with a global state, but also faster.</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler010M extends EulerApp {
  private type Sieve = Array[Boolean]

  private val limit = 2_000_000
  private val sieve = Array(false, false) ++ Array.fill(limit - 2)(true)
  private var primeSum = 0L

  override def execute(): Long = {
    fillSieve(2)
    primeSum
  }

  @tailrec
  private def fillSieve(n: Int): Sieve = {
    if (n == limit) sieve
    else if (sieve(n)) {
      primeSum += n
      sieveWithNewPrime(n)
      fillSieve(n + 1)
    } else fillSieve(n + 1)
  }

  private def sieveWithNewPrime(newPrime: Int): Unit = {
    var nonPrime = newPrime * 2
    // We will mark all the multiplies of the new prime number, up to 'limit' as non primes
    while (nonPrime &lt; limit) {
      sieve(nonPrime) = false
      nonPrime = nonPrime + newPrime
    }
  }
}
</code></pre>
<p>We could also cut the numbers of elements stored by twice if we don't check the even numbers, we know that they are
not primes, but that would make the solution more complex. We could also use a more memory-efficient structure, such
as BitSet, which requires 1 bit to store 1 number, as compared to array of booleans where we need 1 byte to store a
boolean. It would also increase the complexity, since BitSets are a bit more tricky to handle. Could also decrease
the performance, but I haven't checked that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-grid"><a class="header" href="#largest-product-in-a-grid">Largest Product in a Grid</a></h1>
<p>In the \(20 × 20\) grid below, four numbers along a diagonal line have been marked in red.</p>
<p style="text-align: center;">
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
32 98 81 28 64 23 67 10 <span style="color: #a00;"><b>26</b></span> 38 40 67 59 54 70 66 18 38 64 70<br>
67 26 20 68 02 62 12 20 95 <span style="color: #a00;"><b>63</b></span> 94 39 63 08 40 91 66 49 94 21<br>
24 55 58 05 66 73 99 26 97 17 <span style="color: #a00;"><b>78</b></span> 78 96 83 14 88 34 89 63 72<br>
21 36 23 09 75 00 76 44 20 45 35 <span style="color: #a00;"><b>14</b></span> 00 61 33 97 34 31 33 95<br>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br></p>
<p>The product of these numbers is \(26 × 63 × 78 × 14 = 1788696\).</p>
<p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally)
in the \(20 × 20\) grid?</p>
<h2 id="solution-10"><a class="header" href="#solution-10">Solution</a></h2>
<p>This large blocks of numbers may look daunting, but in reality the number of cases we have to check is pretty small.
It's small enough that we can check all of them and then take the maximum.</p>
<p>First, we'll load the data line by line and then create a 2d array of integers that represents the problem data set:</p>
<pre><code class="language-scala">def prepareData(): Array[Array[Int]] =
  loadFileAsLines().map(_.split(" ").map(_.toInt)).toArray
</code></pre>
<p>The <code>loadFileAsLines()</code> is a helper method that does exactly what its name says: it loads the file as a list of strings,
where each string is a line.</p>
<p>Let's define our search function like that:</p>
<pre><code class="language-scala">private def findLargestProduct(matrix: Array[Array[Int]]): Long = ???
</code></pre>
<p>Because of how the data was loaded, <code>matrix(0)</code> would return the first row, and <code>matrix(0)(0)</code> will give us the first
element within the first row.</p>
<p>So, we can iterate over all the elements like that:</p>
<pre><code class="language-scala">for (col &lt;- matrix.indices; row &lt;- matrix(col).indices)
</code></pre>
<p>The <code>.indices</code> method is pretty convenient as it returns a range that corresponds to the array length, so we don't
need to worry about going out of bounds.</p>
<p>If we're at the element of (0, 0), then naturally we can only check the product in three directions: down,
right and diagonally (right, down). If we're going from left to right, do we ever need to check the left direction?</p>
<p>Not really. Because if we're checking the right direction at (0, 0), it will be the same as checking the left direction
at (0, 3). In both cases we're multiplying these elements: (0, 0), (0, 1), (0, 2), (0, 3).</p>
<p>Likewise, when checking the diagonals, we can check only those going down. Overall, this gives us four directions
to check: "right", "down", "right-down", "left-down".</p>
<p>Checking each direction is a matter of defining right constraints, so we don't go out of bounds. Let's analyze how
would that look for the "right" direction.</p>
<p>First, we need to define a condition: <code>col &lt; matrix(row).length - 3</code>. The <code>matrix(row).length</code> returns the length of
the first row. We could as well define a constant of 20, but let's keep it dynamic as a good practice. With this
check, we're making sure that the last column we're checking will be 16, so we can check elements 16, 17, 18, 19.
Our array has 20 elements, but they're indexed from 0, so the last element has index 19.</p>
<p>Let's summarize it then. Our check for the "right" direction will look as follows:</p>
<pre><code class="language-scala">var max: Long = 0
if (col &lt; matrix(row).length - 3) {
   max = Math.max(max, matrix(row)(col) * matrix(row)(col + 1) * matrix(row)(col + 2) * matrix(row)(col + 3))
}
</code></pre>
<p>Now we just need to define the checks for other 3 directions and that's it, we'll have our solution.</p>
<p>Here's the complete solution. It's a mutable one, but just a little bit. We maintain a mutable, local <code>max</code> that keeps
the maximum product we've found so far.</p>
<pre><code class="language-scala">object Euler011M extends EulerApp {

  override def execute(): Long = findLargestProduct(prepareData())

  def prepareData(): Array[Array[Int]] =
    loadFileAsLines().map(_.split(" ").map(_.toInt)).toArray

  private def findLargestProduct(matrix: Array[Array[Int]]): Long = {
    var max: Long = 0

    for (col &lt;- matrix.indices; row &lt;- matrix(col).indices) {
      if (row &lt; matrix.length - 3) {
        max = Math.max(max, matrix(row)(col) * matrix(row + 1)(col) * matrix(row + 2)(col) * matrix(row + 3)(col))
      }

      if (col &lt; matrix(row).length - 3) {
        max = Math.max(max, matrix(row)(col) * matrix(row)(col + 1) * matrix(row)(col + 2) * matrix(row)(col + 3))
      }

      if ((col &lt; matrix(row).length - 3) &amp;&amp; (row &gt; 3)) {
        max = Math.max(
          max,
          matrix(row)(col) * matrix(row - 1)(col + 1) * matrix(row - 2)(col + 2) * matrix(row - 3)(col + 3)
        )
      }

      if ((col &lt; matrix(row).length - 3) &amp;&amp; (row &lt; matrix.length - 3)) {
        max = Math.max(
          max,
          matrix(row)(col) * matrix(row + 1)(col + 1) * matrix(row + 2)(col + 2) * matrix(row + 3)(col + 3)
        )
      }
    }

    max
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="highly-divisible-triangular-number"><a class="header" href="#highly-divisible-triangular-number">Highly Divisible Triangular Number</a></h1>
<p>The sequence of triangle numbers is generated by adding the natural numbers. So the \(7^{th}\) triangle number would
be
\(1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\). The first ten terms would be:</p>
<p>\begin{align} 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 \end{align}</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<p>\begin{align}
\mathbf 1 &amp;\colon 1\\
\mathbf 3 &amp;\colon 1,3\\
\mathbf 6 &amp;\colon 1,2,3,6\\
\mathbf{10} &amp;\colon 1,2,5,10\\
\mathbf{15} &amp;\colon 1,3,5,15\\
\mathbf{21} &amp;\colon 1,3,7,21\\
\mathbf{28} &amp;\colon 1,2,4,7,14,28
\end{align}</p>
<p>We can see that \(28\) is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>
<h2 id="solution-11"><a class="header" href="#solution-11">Solution</a></h2>
<p>Generating the triangle numbers is very easy. The real challenge is to find the number of divisors in an efficient way.</p>
<p>The naive method wouldn't work. You can try it, but it will take too long to finish, because the number that has 500
divisors will be quite large.</p>
<p>Any number can be represented as a product of prime factors. For example, \(28\) is \(2^2 × 7^1\).</p>
<p>We can get these factors by dividing the 28 by its prime factors:</p>
<p>\begin{align}
28 ÷ 2 = 14\\
14 ÷ 2 = 7\\
7 ÷ 7 = 1\\
\end{align}</p>
<p>The next interesting thing is, that if we take increase those factors by one and multiply them with each other, we'll
get a total number of factors: \((2+1)(1+1) = 6\).</p>
<p>We can leverage those facts to quickly find the number of divisors, the only thing we need is a list of primes to use.</p>
<p>Let's assume that our number will fit as a regular integer, in that case, we can get all primes like that:</p>
<pre><code class="language-scala">  private val primes: Seq[Int] =
  (2 to Math.sqrt(Integer.MAX_VALUE).toInt)
    .filter(EulerHelper.naiveIsPrime)
</code></pre>
<p>We could also use a sieve of Eratosthenes here, but let's keep it simple instead.</p>
<p>Getting next triangle numbers is easy, we can do it with a simple recursive function that keeps the current triangle
number as <code>n</code> and the addend that was used to create it as <code>k</code>. Each iteration we increase <code>k</code> by one and calculate
<code>n</code> from <code>n + k</code>.</p>
<pre><code class="language-scala">  @tailrec
private def findTriangleNumber(n: Int = 1, k: Int = 2): Int =
  if (divisors(n) &gt; 500) n
  else findTriangleNumber(n + k, k + 1)
</code></pre>
<p>The missing part is to implement the <code>divisors(n)</code> function that calculates the number of divisors of <code>n</code>.</p>
<p>We've already discussed the algorithm, let's think about the method signature:</p>
<pre><code class="language-scala">  @tailrec
private def divisors(
                      n: Int,
                      primes: Seq[Int] = primes,
                      divisorsFound: Map[Int, Int] = Map.empty
                    ): Int 
</code></pre>
<ul>
<li><code>n</code> is the number</li>
<li><code>primes</code> is a sequence of primes, initially all of them</li>
<li><code>divisorsFound</code> is how we can represent the prime factors. Map key is a prime, and value is a factor.</li>
<li>the return value is the number of divisors</li>
</ul>
<p>Let's take a look at the whole solution:</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler012 extends EulerApp {
  override def execute(): Any = findTriangleNumber()

  private val primes: Seq[Int] =
    (2 to Math.sqrt(Integer.MAX_VALUE).toInt)
      .filter(EulerHelper.naiveIsPrime)

  @tailrec
  private def findTriangleNumber(n: Int = 1, k: Int = 2): Int =
    if (divisors(n) &gt; 500) n
    else findTriangleNumber(n + k, k + 1)

  @tailrec
  private def divisors(
      n: Int,
      primes: Seq[Int] = primes,
      divisorsFound: Map[Int, Int] = Map.empty
  ): Int = {
    val prime = primes.head

    if (n % prime == 0) {
      val newFactor = divisorsFound.get(prime) match {
        case Some(factor) =&gt; factor + 1
        case None         =&gt; 1
      }
      divisors(
        n / prime,
        primes,
        divisorsFound + (prime -&gt; newFactor)
      )
    } else if (prime &gt; n) divisorsFound.foldLeft(1) { case (accumulator, (_, factor)) =&gt;
      accumulator * (factor + 1)
    }
    else divisors(n, primes.tail, divisorsFound)
  }

}
</code></pre>
<p>It covers three cases:</p>
<pre><code class="language-scala">if (n % prime == 0)
</code></pre>
<p>This condition is met when we're processing a prime that can divide a number.
It will result in the <code>divisorsFound</code> being updated.</p>
<pre><code class="language-scala">else if (prime &gt; n) 
</code></pre>
<p>If we hit a prime that's higher or equal than n, then it's time to calculate the divisors
based on the <code>divisorsFound</code> map. Keep in mind that <code>n</code> decreases every time we find a new divisor.</p>
<p>In fact, we could also use a <code>(n == 1)</code> condition here.</p>
<pre><code class="language-scala">else divisors(n, primes.tail, divisorsFound)
</code></pre>
<p>If previous conditions are both false, then it means that we simply need to check the next prime, because the current
one is not a divisor and we're not finished yet.</p>
<h2 id="closing-notes"><a class="header" href="#closing-notes">Closing notes</a></h2>
<p>The solution is functional, it doesn't mutate any of the collections it uses, but despite that it's still pretty fast.</p>
<p>Obviously it could be faster, if, for example, instead of calling the <code>primes.tail</code> every time we want to move to the
next prime number we simply maintained an index of which prime we're processing.</p>
<p>Likewise, creating a new <code>divisorsFound</code> map after every change will be less efficient than reusing a single map
and mutating it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="large-sum"><a class="header" href="#large-sum">Large Sum</a></h1>
<p>Work out the first ten digits of the sum of the following one-hundred-digit numbers.</p>
<div style="text-align: center !important; font-family: "Lucida Consolas", "Consolas", "Courier New", monospace;">
37107287533902102798797998220837590246510135740250<br>
46376937677490009712648124896970078050417018260538<br>
74324986199524741059474233309513058123726617309629<br>
91942213363574161572522430563301811072406154908250<br>
23067588207539346171171980310421047513778063246676<br>
89261670696623633820136378418383684178734361726757<br>
28112879812849979408065481931592621691275889832738<br>
44274228917432520321923589422876796487670272189318<br>
47451445736001306439091167216856844588711603153276<br>
70386486105843025439939619828917593665686757934951<br>
62176457141856560629502157223196586755079324193331<br>
64906352462741904929101432445813822663347944758178<br>
92575867718337217661963751590579239728245598838407<br>
58203565325359399008402633568948830189458628227828<br>
80181199384826282014278194139940567587151170094390<br>
35398664372827112653829987240784473053190104293586<br>
86515506006295864861532075273371959191420517255829<br>
71693888707715466499115593487603532921714970056938<br>
54370070576826684624621495650076471787294438377604<br>
53282654108756828443191190634694037855217779295145<br>
36123272525000296071075082563815656710885258350721<br>
45876576172410976447339110607218265236877223636045<br>
17423706905851860660448207621209813287860733969412<br>
81142660418086830619328460811191061556940512689692<br>
51934325451728388641918047049293215058642563049483<br>
62467221648435076201727918039944693004732956340691<br>
15732444386908125794514089057706229429197107928209<br>
55037687525678773091862540744969844508330393682126<br>
18336384825330154686196124348767681297534375946515<br>
80386287592878490201521685554828717201219257766954<br>
78182833757993103614740356856449095527097864797581<br>
16726320100436897842553539920931837441497806860984<br>
48403098129077791799088218795327364475675590848030<br>
87086987551392711854517078544161852424320693150332<br>
59959406895756536782107074926966537676326235447210<br>
69793950679652694742597709739166693763042633987085<br>
41052684708299085211399427365734116182760315001271<br>
65378607361501080857009149939512557028198746004375<br>
35829035317434717326932123578154982629742552737307<br>
94953759765105305946966067683156574377167401875275<br>
88902802571733229619176668713819931811048770190271<br>
25267680276078003013678680992525463401061632866526<br>
36270218540497705585629946580636237993140746255962<br>
24074486908231174977792365466257246923322810917141<br>
91430288197103288597806669760892938638285025333403<br>
34413065578016127815921815005561868836468420090470<br>
23053081172816430487623791969842487255036638784583<br>
11487696932154902810424020138335124462181441773470<br>
63783299490636259666498587618221225225512486764533<br>
67720186971698544312419572409913959008952310058822<br>
95548255300263520781532296796249481641953868218774<br>
76085327132285723110424803456124867697064507995236<br>
37774242535411291684276865538926205024910326572967<br>
23701913275725675285653248258265463092207058596522<br>
29798860272258331913126375147341994889534765745501<br>
18495701454879288984856827726077713721403798879715<br>
38298203783031473527721580348144513491373226651381<br>
34829543829199918180278916522431027392251122869539<br>
40957953066405232632538044100059654939159879593635<br>
29746152185502371307642255121183693803580388584903<br>
41698116222072977186158236678424689157993532961922<br>
62467957194401269043877107275048102390895523597457<br>
23189706772547915061505504953922979530901129967519<br>
86188088225875314529584099251203829009407770775672<br>
11306739708304724483816533873502340845647058077308<br>
82959174767140363198008187129011875491310547126581<br>
97623331044818386269515456334926366572897563400500<br>
42846280183517070527831839425882145521227251250327<br>
55121603546981200581762165212827652751691296897789<br>
32238195734329339946437501907836945765883352399886<br>
75506164965184775180738168837861091527357929701337<br>
62177842752192623401942399639168044983993173312731<br>
32924185707147349566916674687634660915035914677504<br>
99518671430235219628894890102423325116913619626622<br>
73267460800591547471830798392868535206946944540724<br>
76841822524674417161514036427982273348055556214818<br>
97142617910342598647204516893989422179826088076852<br>
87783646182799346313767754307809363333018982642090<br>
10848802521674670883215120185883543223812876952786<br>
71329612474782464538636993009049310363619763878039<br>
62184073572399794223406235393808339651327408011116<br>
66627891981488087797941876876144230030984490851411<br>
60661826293682836764744779239180335110989069790714<br>
85786944089552990653640447425576083659976645795096<br>
66024396409905389607120198219976047599490197230297<br>
64913982680032973156037120041377903785566085089252<br>
16730939319872750275468906903707539413042652315011<br>
94809377245048795150954100921645863754710598436791<br>
78639167021187492431995700641917969777599028300699<br>
15368713711936614952811305876380278410754449733078<br>
40789923115535562561142322423255033685442488917353<br>
44889911501440648020369068063960672322193204149535<br>
41503128880339536053299340368006977710650566631954<br>
81234880673210146739058568557934581403627822703280<br>
82616570773948327592232845941706525094512325230608<br>
22918802058777319719839450180888072429661980811197<br>
77158542502016545090413245809786882778948721859617<br>
72107838435069186155435662884062257473692284509516<br>
20849603980134001723930671666823555245252804609722<br>
53503534226472524250874054075591789781264330331690<br></div>
<h2 id="solution-12"><a class="header" href="#solution-12">Solution</a></h2>
<p>That's a lot of long numbers! Fortunately for us, the standard library in Scala makes this task very easy.
Code should be self-explanatory, there isn't much to add.</p>
<pre><code class="language-scala">object Euler013 extends EulerApp {
  override def execute(): String =
    loadFileAsLines().map(BigInt.apply).sum.toString().take(10)
}
</code></pre>
<p>The <code>loadFileAsLines()</code> loads the numbers from a text file, lime by line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="power-digit-sum"><a class="header" href="#power-digit-sum">Power Digit Sum</a></h1>
<p>\(2^{15} = 32768\) and the sum of its digits is \(3 + 2 + 7 + 6 + 8 = 26\).</p>
<p>What is the sum of the digits of the number \(2^{1000}\)?</p>
<h2 id="solution-13"><a class="header" href="#solution-13">Solution</a></h2>
<p>Due to the rich standard library in Scala, this problem is extremely easy. We can solve it in one line only!</p>
<pre><code class="language-scala">object Euler016 extends EulerApp {
  override def execute(): Int = (BigInt(2) ^ 1000).toString().map(_.asDigit).sum
}
</code></pre>
<p>It even runs very fast. If we wanted to avoid using <code>BigInt</code>, then it wouldn't be much harder. We could store the
individual digits in an array and each multiplication would double all the indexes by two. We'd also need to handle
the carrying over.</p>
<p>Still pretty straightforward, not really worth the effort to go through it.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
