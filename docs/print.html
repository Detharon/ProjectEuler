<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Guide to Project Euler in Scala</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Project Euler in Scala</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-guide"><a class="header" href="#about-this-guide">About this guide</a></h1>
<p>This guide contains solutions for the first 100 problems from the Project Euler website.</p>
<p>The code is shared for educational purposes, demonstrating how these problems can be approached using Scala.
There are many other sites that discuss Project Euler problems, but here, the purpose it twofold:
discuss the problem while emphasizing Scala's strengths and show code that's both efficient and idiomatic,
easy to read and powerful.</p>
<p>So, whenever possible, a functional programming style is used, avoiding mutable state and vars. Some solutions
intentionally deviate from this approach for performance comparison;
these are marked with an ‘M’ suffix in their filenames.</p>
<p>While the non-functional style may yield greater efficiency by reducing object allocations, it often results in less
readable and more error-prone code, so it is included primarily for contrast and learning purposes.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>It's an individual works, that's heavily influenced by my personal style, but I'm open for contributions.
If you want to add your some extra insights, you've found an error or a mistake, please send a pull request
or raise an issue in GitHub.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project status</a></h2>
<p>The project it still in progress, with many problems missing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="problem-solutions"><a class="header" href="#problem-solutions">Problem solutions</a></h1>
<p>You can find the code for all the problems in the project repository, in <code>src/main/scala</code> directory.
All examples are runnable, and they only print the solution, along the execution time.</p>
<p>A commonly used code can be found in <code>EulerHelper</code> class, but other than that, the solutions are self-contained.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiples-of-3-or-5"><a class="header" href="#multiples-of-3-or-5">Multiples of 3 or 5</a></h1>
<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these
multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>The only tricky part of this exercise comes from the fact that we cannot simply count the multiplies of 3,
then calculate the multiplies of 5, and add these two numbers up. If we did that, then the numbers that are divisible
by both 3 and 5 would be calculated twice.</p>
<p>In this solution, we create three sets of numbers. If a number of divisible by both 3 and 5, then it's divisible by 15,
so we can find those numbers and subtract them from the two other sets.</p>
<pre><code class="language-scala">object Euler001 extends EulerApp {
  override def execute(): Int = {
    val threes = (3 until 1000 by 3).sum
    val fives = (5 until 1000 by 5).sum
    val fifteens = (15 until 1000 by 15).sum

    threes + fives - fifteens
  }
}
</code></pre>
<p>The problem can be also solved by checking all the numbers to see if they're divisible by 3 or 5.
Shorter, nothing gets counted twice, but you may find it harder to read.</p>
<pre><code class="language-scala">(3 until 1000).filter(n =&gt; n % 3 == 0 || n % 5 == 0).sum
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fibonacci-numbers"><a class="header" href="#even-fibonacci-numbers">Even Fibonacci Numbers</a></h1>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.</p>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<p>The numbers are small enough to calculate it in a matter of milliseconds without any optimisations.
Fibonacci implementation is done with a LazyList to make it infinite. Is this an efficient approach?
Not really, because <code>LazyList</code> memoizes all the elements, but we need just the previous 2.</p>
<p>In this case, due to how easy this task is, let's keep it as it is.</p>
<pre><code class="language-scala">object Euler002 extends EulerApp {
  override def execute(): Int =
    fibonacci.filter(_ % 2 == 0).takeWhile(_ &lt; 4_000_000).sum

  val fibonacci: LazyList[Int] = 1 #:: fibonacciFunction(1, 2)

  private def fibonacciFunction(a: Int, b: Int): LazyList[Int] =
    a #:: fibonacciFunction(b, a + b)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-prime-factor"><a class="header" href="#largest-prime-factor">Largest Prime Factor</a></h1>
<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
<p>What is the largest prime factor of the number 600851475143?</p>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<p>Before implementing anything, let's think how finding the prime factors works.
Let's consider the number from the description, 13195. We can just try all the numbers until we hit a prime, then
check if it's divisible by this prime. Once we found a factor, we can just divide the original number by it.</p>
<p>So, the 13195 turns into 13195 / 5 = 2639.</p>
<p>Then 2639 / 7 = 377.</p>
<p>Then 377 / 13 = 29.</p>
<p>And finally 29 / 29 = 1.</p>
<p>In fact, we could check each result to see if it's a prime, because if it is, then we know that we've found
the biggest prime factor and can just return it.</p>
<p>But there are some reasons not to do that as well. Let's take a look at a complete solution, without that final
optimization:</p>
<pre><code class="language-scala">import EulerHelper.naiveIsPrime

import scala.annotation.tailrec

object Euler003 extends EulerApp {
  override def execute(): Long = primeFactors(600851475143L).max

  @tailrec
  private def primeFactors(n: Long, i: Int = 2, primesFound: List[Int] = List.empty): List[Int] =
    if (n == 1) primesFound
    else if (n % i == 0 &amp;&amp; naiveIsPrime(i)) primeFactors(n / i, i + 1, primesFound :+ i)
    else primeFactors(n, i + 1, primesFound)
}
</code></pre>
<p>The prime check is done in a naive way, by checking all the numbers. It's not efficient, and in the process we're
checking multiple numbers over and over again, but it's still blazing fast.
Now, the reason why the final optimization was not done, because it would make the app run much slower: doing the same
check on longs rather than integers, made the app run 5 times as long.</p>
<pre><code class="language-scala">  extension (n: Int) {
    def naiveIsPrime: Boolean = n match {
      case n if n &lt; 2 =&gt; false
      case _          =&gt; (2 to Math.sqrt(n.toDouble).toInt).forall(n % _ != 0)
    }
  }
</code></pre>
<p>In the end, it doesn't make sense to overly optimize such a simple problem.
Out solution solves it and is easy to understand, so let's move on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-palindrome-product"><a class="header" href="#largest-palindrome-product">Largest Palindrome Product</a></h1>
<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two
2-digit numbers is 9009 = 91 * 99</p>
<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<p>A brute-force solution would also work reasonably well, but we can actually reduce the number of numbers to be checked.</p>
<p>We know that multiplying two 3-digit numbers will give us a 6-digit number at most,
so the palindrome we're looking for has the "abccba" form, or: 100000a + 10000b + 1000c + 100c + 10b + a.</p>
<p>If we add those numbers we get "100001a + 10010b + 1100c".
We can then factor out 11, which means that our palindrome has to be divisible by 11: 11(9091a + 910b + 100c)</p>
<p>One of the numbers then has to be divisible by 11, because it's a prime number.
We can start from 990 instead of 999 and decrease the numbers checked by 11.</p>
<p>As for checking if a string is a palindrome, there are many ways to do that. It can be done iteratively, recursively,
or with built-in functions like here. Neither changes the run time, so it doesn't matter much for this problem.</p>
<pre><code class="language-scala">object Euler004 extends EulerApp {
  override def execute(): Int = (for {
    a &lt;- 990 to 100 by -11
    b &lt;- 999 to 100 by -1
  } yield a * b)
    .filter(n =&gt; isPalindrome(n.toString))
    .max

  def isPalindrome(s: String): Boolean = s == s.reverse
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smallest-multiple"><a class="header" href="#smallest-multiple">Smallest Multiple</a></h1>
<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>
<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p>
<h2 id="lets-make-it-easier"><a class="header" href="#lets-make-it-easier">Let's make it easier</a></h2>
<p>First, let's try to decrease a bit the number of numbers we'll need to check. We can analyze the simpler problem for
which we already know the answer.</p>
<p>The 2520 is divisible by all numbers from 1 to 10. We know that among those numbers, 2, 3, 5, 7 are primes. So, if the
number we're looking for is divisible by all these prime numbers, then it must be a multiple of (2 * 3 * 5 * 7) = 210.</p>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>We can follow the same logic to find a number that's evenly divisible by all numbers from 1 to 20.</p>
<p>Prime numbers in this set are: 2, 3, 5, 7, 11, 13, 17, 19. The number we're looking for, then, must be a multiple of
2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690.</p>
<p>Let's try to find that number!</p>
<pre><code class="language-scala">object Euler005 extends EulerApp {
  // 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690
  override def execute(): Int = Iterator
    .from(9699690, 9699690)
    .find { n =&gt;
      (2 to 20).forall(k =&gt; n % k == 0)
    }
    .get
}
</code></pre>
<p>If we wanted to improve it even further, then we can notice that we don't need to check again if our numbers are
divisible by all these prime numbers. Also, multiplies of these numbers, such as 6 (2 * 3), no need to be checked either.</p>
<p>That's because every number that's divisible by both 2 and 3 must be divisible by 6.</p>
<p>We don't need to make it more complex than necessary. The current solution already runs in 1-2 ms on my machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sum-square-difference"><a class="header" href="#sum-square-difference">Sum Square Difference</a></h1>
<p>The sum of the squares of the first ten natural numbers is,</p>
<p>\(1^2 + 2^2 + ... + 10^2 = 385\)</p>
<p>The square of the sum of the first ten natural numbers is,</p>
<p>\((1 + 2 + ... + 10)^2 = 55^2 = 3025\)</p>
<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is</p>
<p>\(3025 - 385 = 2640\)</p>
<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<p>It's a pretty straightforward problem. We can simply write down the problem literally, without any optimizations, and
we're good to go. Scala's expressiveness makes this task a breeze and the resulting code is easy to understand.</p>
<p>To make it extra concise, let's also define a "square" extension method.</p>
<pre><code class="language-scala">object Euler006 extends EulerApp {
  override def execute(): Int = squareOfSums(100) - sumOfSquares(100)

  private def sumOfSquares(n: Int) = (1 to n).map(_.square).sum

  private def squareOfSums(n: Int) = (1 to n).sum.square

  extension (i: Int) {
    def square: Int = i * i
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-001st-prime"><a class="header" href="#10-001st-prime">10 001st Prime</a></h1>
<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>
<p>What is the 10001st prime number?</p>
<h2 id="solution-6"><a class="header" href="#solution-6">Solution</a></h2>
<p>We can simply brute-force this problem by using the most naive prime check, since the 10001st prime will be a low
number. This solution is pretty fast, even though the algorithm is not very efficient.</p>
<p>As you can see, we don't even filter out even numbers higher than 2 (or all the multiplies of already found primes),
but we'll need these methods later on. For now, a basic algorithm does pretty well.</p>
<pre><code class="language-scala">import EulerHelper.naiveIsPrime

object Euler007 extends EulerApp {
  override def execute(): Any = Iterator
    .from(2)
    .filter(naiveIsPrime)
    .drop(10000)
    .next()
}
</code></pre>
<p>And for the reference, that's how we check if a number is a prime. A brute-force solution, that ran in 13 ms on my
machine, which is pretty good already.</p>
<pre><code class="language-scala">  extension (n: Int) {
    def naiveIsPrime: Boolean = n match {
      case n if n &lt; 2 =&gt; false
      case _          =&gt; (2 to Math.sqrt(n.toDouble).toInt).forall(n % _ != 0)
    }
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-series"><a class="header" href="#largest-product-in-a-series">Largest Product in a Series</a></h1>
<p>The four adjacent digits in the 1000-digit number that have the greatest product are</p>
<p>\(9 * 9 * 8 * 9 = 5832\)</p>
<p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p>
<h2 id="solution-7"><a class="header" href="#solution-7">Solution</a></h2>
<p>The number might look daunting, but for any algorithm it's small enough that we don't need to optimize it much.
This is the shortest solution (code-wise), but also the least efficient. We split the string into 13-element sliding windows,
then calculate the product of the digits in each window.</p>
<p>Once we have the list of products, we simply take the maximum. Easy-peasy.
Could you explain why this solution is inefficient and what could significantly improve it, even at the cost of no
longer being functional?</p>
<pre><code class="language-scala">object Euler008 extends EulerApp {
  override def execute(): Any = {
    val number = "73167176531330624919225119674426574742355349194934" +
      "96983520312774506326239578318016984801869478851843" +
      "85861560789112949495459501737958331952853208805511" +
      "12540698747158523863050715693290963295227443043557" +
      "66896648950445244523161731856403098711121722383113" +
      "62229893423380308135336276614282806444486645238749" +
      "30358907296290491560440772390713810515859307960866" +
      "70172427121883998797908792274921901699720888093776" +
      "65727333001053367881220235421809751254540594752243" +
      "52584907711670556013604839586446706324415722155397" +
      "53697817977846174064955149290862569321978468622482" +
      "83972241375657056057490261407972968652414535100474" +
      "82166370484403199890008895243450658541227588666881" +
      "16427171479924442928230863465674813919123162824586" +
      "17866458359124566529476545682848912883142607690042" +
      "24219022671055626321111109370544217506941658960408" +
      "07198403850962455444362981230987879927244284909188" +
      "84580156166097919133875499200524063689912560717606" +
      "05886116467109405077541002256983155200055935729725" +
      "71636269561882670428252483600823257530420752963450"

    number.sliding(13).map(_.map(_.asDigit.toLong).product).max
  }
}
</code></pre>
<h2 id="mutable-solution"><a class="header" href="#mutable-solution">Mutable solution</a></h2>
<p>In the earlier approach, the sliding windows were completely independent of one another, which made it immutable, but
as I've also mentioned -- pretty inefficient.</p>
<p>By calculating the product of 13 elements, we were performing 11 redundant multiplications in each neighboring window.</p>
<p>Instead, we can maintain a running product — dividing by the digit that leaves the window
and multiplying by the new digit that enters it. The only catch here are the zeroes that break the computation chain.</p>
<p>While this approach is definitely faster, it’s also more error-prone and harder to read.
For example, consider the following line:</p>
<pre><code class="language-scala">previous = buffer.remove(0).asDigit
</code></pre>
<p>It’s not immediately clear that <code>remove(0)</code> returns the element being removed.
Moreover, if the <code>.asDigit</code> call were omitted, the code would still compile and run,
but it would silently produce an incorrect result. For such a small task, the optimization is not worth
the effort, so treat it merely as a mental exercise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-pythagorean-triplet"><a class="header" href="#special-pythagorean-triplet">Special Pythagorean Triplet</a></h1>
<p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,</p>
<p>\(a^2 + b^2 = c^2\)</p>
<p>For example \(3^2 + 4^2 = 9 + 16 = 25 = 5^2\).</p>
<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.</p>
<p>Find the product abc.</p>
<h2 id="solution-8"><a class="header" href="#solution-8">Solution</a></h2>
<p>The numbers are low enough for a naive approach, so let's use it, while keeping the code nice and clean.</p>
<p>We need to check all combinations of a, b, c for which a + b + c = 1000 and find those that form a
Pythagorean triplet.</p>
<p>This naive algorithm starts from the highest possible 'c', keeps the sum of parameters at 1000, while gradually
incrementing 'b' and decrementing 'c' until this it's possible. This condition (b == c - 2 || b == c - 1) indicates
that the next triangle can't be created this way, so we need to increase the 'a' instead, while resetting the other
two parameters: 'b' to the lowest possible one, 'c' to whatever will give a sum of 1000.</p>
<p>It uses a LazyList which does keeps all the previous elements in memory. That's not something we need, but it makes
the code pretty concise. Let's also try a mutable approach.</p>
<pre><code class="language-scala">object Euler009 extends EulerApp {
  override def execute(): Any = {
    triangles.dropWhile(!isPythagorean(_)).head.product
  }

  type Triangle = (Int, Int, Int)
  val triangles: LazyList[Triangle] = triangles(1, 2, 997)

  private def triangles(a: Int, b: Int, c: Int): LazyList[Triangle] = {
    (a, b, c) #:: {
      if (b == c - 2 || b == c - 1) triangles(a + 1, a + 2, 997 - (2 * a))
      else triangles(a, b + 1, c - 1)
    }
  }

  private def isPythagorean(triangle: Triangle): Boolean = {
    val Triangle(a, b, c) = triangle
    a * a + b * b == c * c
  }

  extension (t: Triangle) {
    def product: Int = t._1 * t._2 * t._3
  }
}
</code></pre>
<h2 id="mutable-solution-1"><a class="header" href="#mutable-solution-1">Mutable solution</a></h2>
<p>This time let's aim for maximum efficiency. Even though the idiomatic solution found the solution pretty fast
on my machine, the optimized one is about 10 to 15 times faster, even though they share the same algorithm.</p>
<p>It's also more concise. It looks rather enigmatic, which is the usual pitfalls for the optimized solutions, but
in this case the difference in performance was quite substantial.</p>
<pre><code class="language-scala">object Euler009M extends EulerApp {
  override def execute(): Any = {
    var a = 1
    var b = 2
    var c = 997
    var found = false

    while (!found) {
      if (a * a + b * b == c * c) found = true
      else {
        if (b == c - 1 || b == c - 2) {
          a = a + 1
          b = a + 1
          c = 1000 - b - a
        } else {
          b = b + 1
          c = c - 1
        }
      }
    }

    a * b * c
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
