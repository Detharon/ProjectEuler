<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Guide to Project Euler in Scala</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-03bae5c3.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-efb3617e.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Project Euler in Scala</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="about-this-guide"><a class="header" href="#about-this-guide">About this guide</a></h1>
<p>This guide contains solutions for the first 100 problems from the Project Euler website.
Full code, in a form of runnable classes, is available on GitHub: https://github.com/Detharon/ProjectEuler</p>
<p>The code is shared for educational purposes, demonstrating how these problems can be approached using Scala.
There are many other sites that discuss Project Euler problems, but here, the purpose it twofold:
discuss the problem while emphasizing Scala’s strengths of making efficient code that’s easy to understand.</p>
<p>So, whenever possible, a functional programming style is used, avoiding mutable state and vars. Some solutions
intentionally deviate from this approach for performance comparison;
these are marked with an ‘M’ suffix in their filenames.</p>
<p>While the non-functional style may yield greater efficiency by reducing object allocations, it often results in less
readable and more error-prone code, so it is included primarily for contrast and learning purposes.</p>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to use this guide</a></h2>
<p>My advice would be to read the solutions only when you’ve already solved the problem. It’s normal to struggle at the
beginning. The first solution can be unoptimized and too slow to give the final result, but it’s a good starting
point to think what can be improved.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Even though it’s an individual work, that’s heavily influenced by my personal style, I’m open for contributions.
If you want to add your some extra insights, you’ve found an error or a mistake, please send a pull request
or raise an issue in GitHub.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project status</a></h2>
<p>The project it still in progress, with many problems missing.
Some of them are solved but not described yet in this book.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="problem-solutions"><a class="header" href="#problem-solutions">Problem solutions</a></h1>
<p>You can find the code for all the problems in the project repository, in <code>src/main/scala</code> directory.
All examples are runnable, and they only print the solution, along the execution time.</p>
<p>A commonly used code can be found in <code>EulerHelper</code> class, but other than that, the solutions are self-contained.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="multiples-of-3-or-5"><a class="header" href="#multiples-of-3-or-5">Multiples of 3 or 5</a></h1>
<p>If we list all the natural numbers below 10 that are multiples of \(3\) or \(5\), we get \(3, 5, 6\) and \(9\).
The sum of these multiples is \(23\).
Find the sum of all the multiples of \(3\) or \(5\) below \(1000\).</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>The only tricky part of this exercise comes from the fact that we cannot simply count the multiplies of \(3\),
then calculate the multiplies of \(5\), and add these two numbers up. If we did that, then the numbers that are divisible
by both 3 and 5 would be calculated twice.</p>
<p>In this solution, we create three sets of numbers. If a number of divisible by both \(3\) and \(5\),
then it’s divisible by \(15\), so we can find those numbers and subtract them from the two other sets.</p>
<pre><code class="language-scala">object Euler001 extends EulerApp {
  override def execute(): Int = {
    val threes = (3 until 1000 by 3).sum
    val fives = (5 until 1000 by 5).sum
    val fifteens = (15 until 1000 by 15).sum

    threes + fives - fifteens
  }
}
</code></pre>
<p>The problem can be also solved by checking all the numbers to see if they’re divisible by \(3\) or \(5\).
Shorter, nothing gets counted twice, but you may find it harder to read.</p>
<pre><code class="language-scala">(3 until 1000).filter(n =&gt; n % 3 == 0 || n % 5 == 0).sum
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="even-fibonacci-numbers"><a class="header" href="#even-fibonacci-numbers">Even Fibonacci Numbers</a></h1>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.</p>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<p>The numbers are small enough to calculate it in a matter of milliseconds without any optimisations.
Fibonacci implementation is done with a LazyList to make it infinite. Is this an efficient approach?
Not really, because <code>LazyList</code> memoizes all the elements, but we need just the previous 2.</p>
<p>In this case, due to how easy this task is, let’s keep it as it is.</p>
<pre><code class="language-scala">object Euler002 extends EulerApp {
  override def execute(): Int =
    fibonacci.filter(_ % 2 == 0).takeWhile(_ &lt; 4_000_000).sum

  val fibonacci: LazyList[Int] = 1 #:: fibonacciFunction(1, 2)

  private def fibonacciFunction(a: Int, b: Int): LazyList[Int] =
    a #:: fibonacciFunction(b, a + b)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="largest-prime-factor"><a class="header" href="#largest-prime-factor">Largest Prime Factor</a></h1>
<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
<p>What is the largest prime factor of the number 600851475143?</p>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<p>Before implementing anything, let’s think how finding the prime factors works.
Let’s consider the number from the description, 13195. We can just try all the numbers until we hit a prime, then
check if it’s divisible by this prime. Once we found a factor, we can just divide the original number by it.</p>
<p>So, the 13195 turns into 13195 / 5 = 2639.</p>
<p>Then 2639 / 7 = 377.</p>
<p>Then 377 / 13 = 29.</p>
<p>And finally 29 / 29 = 1.</p>
<p>In fact, we could check each result to see if it’s a prime, because if it is, then we know that we’ve found
the biggest prime factor and can just return it.</p>
<p>But there are some reasons not to do that as well. Let’s take a look at a complete solution, without that final
optimization:</p>
<pre><code class="language-scala">import EulerHelper.naiveIsPrime

import scala.annotation.tailrec

object Euler003 extends EulerApp {
  override def execute(): Long = primeFactors(600851475143L).max

  @tailrec
  private def primeFactors(n: Long, i: Int = 2, primesFound: List[Int] = List.empty): List[Int] =
    if (n == 1) primesFound
    else if (n % i == 0 &amp;&amp; naiveIsPrime(i)) primeFactors(n / i, i + 1, primesFound :+ i)
    else primeFactors(n, i + 1, primesFound)
}
</code></pre>
<p>The prime check is done in a naive way, by checking all the numbers. It’s not efficient, and in the process we’re
checking multiple numbers over and over again, but it’s still blazing fast.
Now, the reason why the final optimization was not done, because it would make the app run much slower: doing the same
check on longs rather than integers, made the app run 5 times as long.</p>
<pre><code class="language-scala">  extension (n: Int) {
    def naiveIsPrime: Boolean = n match {
      case n if n &lt; 2 =&gt; false
      case _          =&gt; (2 to Math.sqrt(n.toDouble).toInt).forall(n % _ != 0)
    }
  }
</code></pre>
<p>In the end, it doesn’t make sense to overly optimize such a simple problem.
Out solution solves it and is easy to understand, so let’s move on.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="largest-palindrome-product"><a class="header" href="#largest-palindrome-product">Largest Palindrome Product</a></h1>
<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two
2-digit numbers is 9009 = 91 * 99</p>
<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<p>A brute-force solution would also work reasonably well, but we can actually reduce the number of numbers to be checked.</p>
<p>We know that multiplying two 3-digit numbers will give us a 6-digit number at most,
so the palindrome we’re looking for has the “abccba” form, or: 100000a + 10000b + 1000c + 100c + 10b + a.</p>
<p>If we add those numbers we get “100001a + 10010b + 1100c”.
We can then factor out 11, which means that our palindrome has to be divisible by 11: 11(9091a + 910b + 100c)</p>
<p>One of the numbers then has to be divisible by 11, because it’s a prime number.
We can start from 990 instead of 999 and decrease the numbers checked by 11.</p>
<p>As for checking if a string is a palindrome, there are many ways to do that. It can be done iteratively, recursively,
or with built-in functions like here. Neither changes the run time, so it doesn’t matter much for this problem.</p>
<pre><code class="language-scala">object Euler004 extends EulerApp {
  override def execute(): Int = (for {
    a &lt;- 990 to 100 by -11
    b &lt;- 999 to 100 by -1
  } yield a * b)
    .filter(n =&gt; isPalindrome(n.toString))
    .max

  def isPalindrome(s: String): Boolean = s == s.reverse
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="smallest-multiple"><a class="header" href="#smallest-multiple">Smallest Multiple</a></h1>
<p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>
<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p>
<h2 id="lets-make-it-easier"><a class="header" href="#lets-make-it-easier">Let’s make it easier</a></h2>
<p>First, let’s try to decrease a bit the number of numbers we’ll need to check. We can analyze the simpler problem for
which we already know the answer.</p>
<p>The 2520 is divisible by all numbers from 1 to 10. We know that among those numbers, 2, 3, 5, 7 are primes. So, if the
number we’re looking for is divisible by all these prime numbers, then it must be a multiple of (2 × 3 × 5 × 7) = 210.</p>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>We can follow the same logic to find a number that’s evenly divisible by all numbers from 1 to 20.</p>
<p>Prime numbers in this set are: 2, 3, 5, 7, 11, 13, 17, 19. The number we’re looking for, then, must be a multiple of
2 × 3 × 5 × 7 × 11 × 13 × 17 × 19 = 9699690.</p>
<p>Let’s try to find that number!</p>
<pre><code class="language-scala">object Euler005 extends EulerApp {
  // 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690
  override def execute(): Int = Iterator
    .from(9699690, 9699690)
    .find { n =&gt;
      (2 to 20).forall(k =&gt; n % k == 0)
    }
    .get
}
</code></pre>
<p>If we wanted to improve it even further, then we can notice that we don’t need to check again if our numbers are
divisible by all these prime numbers. Also, multiplies of these numbers, such as 6 (2 * 3), no need to be checked either.</p>
<p>That’s because every number that’s divisible by both 2 and 3 must be divisible by 6.</p>
<p>We don’t need to make it more complex than necessary. The current solution already runs in 1-2 ms on my machine.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sum-square-difference"><a class="header" href="#sum-square-difference">Sum Square Difference</a></h1>
<p>The sum of the squares of the first ten natural numbers is,</p>
<p>\(1^2 + 2^2 + … + 10^2 = 385\)</p>
<p>The square of the sum of the first ten natural numbers is,</p>
<p>\((1 + 2 + … + 10)^2 = 55^2 = 3025\)</p>
<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is</p>
<p>\(3025 - 385 = 2640\)</p>
<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<p>It’s a pretty straightforward problem. We can simply write down the problem literally, without any optimizations, and
we’re good to go. Scala’s expressiveness makes this task a breeze and the resulting code is easy to understand.</p>
<p>To make it extra concise, let’s also define a “square” extension method.</p>
<pre><code class="language-scala">object Euler006 extends EulerApp {
  override def execute(): Int = squareOfSums(100) - sumOfSquares(100)

  private def sumOfSquares(n: Int) = (1 to n).map(_.square).sum

  private def squareOfSums(n: Int) = (1 to n).sum.square

  extension (i: Int) {
    def square: Int = i * i
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="10-001st-prime"><a class="header" href="#10-001st-prime">10 001st Prime</a></h1>
<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>
<p>What is the 10001st prime number?</p>
<h2 id="solution-6"><a class="header" href="#solution-6">Solution</a></h2>
<p>We can simply brute-force this problem by using the most naive prime check, since the 10001st prime will be a low
number. This solution is pretty fast, even though the algorithm is not very efficient.</p>
<p>As you can see, we don’t even filter out even numbers higher than 2 (or all the multiplies of already found primes),
but we’ll need these methods later on. For now, a basic algorithm does pretty well.</p>
<pre><code class="language-scala">import EulerHelper.naiveIsPrime

object Euler007 extends EulerApp {
  override def execute(): Any = Iterator
    .from(2)
    .filter(naiveIsPrime)
    .drop(10000)
    .next()
}
</code></pre>
<p>And for the reference, that’s how we check if a number is a prime. A brute-force solution, that ran in 13 ms on my
machine, which is pretty good already.</p>
<pre><code class="language-scala">  extension (n: Int) {
    def naiveIsPrime: Boolean = n match {
      case n if n &lt; 2 =&gt; false
      case _          =&gt; (2 to Math.sqrt(n.toDouble).toInt).forall(n % _ != 0)
    }
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="largest-product-in-a-series"><a class="header" href="#largest-product-in-a-series">Largest Product in a Series</a></h1>
<p>The four adjacent digits in the 1000-digit number that have the greatest product are</p>
<p>\(9 × 9 × 8 × 9 = 5832\)</p>
<p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p>
<h2 id="solution-7"><a class="header" href="#solution-7">Solution</a></h2>
<p>The number might look daunting, but for any algorithm it’s small enough that we don’t need to optimize it much.
This is the shortest solution (code-wise), but also the least efficient. We split the string into 13-element sliding windows,
then calculate the product of the digits in each window.</p>
<p>Once we have the list of products, we simply take the maximum. Easy-peasy.
Could you explain why this solution is inefficient and what could significantly improve it, even at the cost of no
longer being functional?</p>
<pre><code class="language-scala">object Euler008 extends EulerApp {
  override def execute(): Any = {
    val number = "73167176531330624919225119674426574742355349194934" +
      "96983520312774506326239578318016984801869478851843" +
      "85861560789112949495459501737958331952853208805511" +
      "12540698747158523863050715693290963295227443043557" +
      "66896648950445244523161731856403098711121722383113" +
      "62229893423380308135336276614282806444486645238749" +
      "30358907296290491560440772390713810515859307960866" +
      "70172427121883998797908792274921901699720888093776" +
      "65727333001053367881220235421809751254540594752243" +
      "52584907711670556013604839586446706324415722155397" +
      "53697817977846174064955149290862569321978468622482" +
      "83972241375657056057490261407972968652414535100474" +
      "82166370484403199890008895243450658541227588666881" +
      "16427171479924442928230863465674813919123162824586" +
      "17866458359124566529476545682848912883142607690042" +
      "24219022671055626321111109370544217506941658960408" +
      "07198403850962455444362981230987879927244284909188" +
      "84580156166097919133875499200524063689912560717606" +
      "05886116467109405077541002256983155200055935729725" +
      "71636269561882670428252483600823257530420752963450"

    number.sliding(13).map(_.map(_.asDigit.toLong).product).max
  }
}
</code></pre>
<h2 id="mutable-solution"><a class="header" href="#mutable-solution">Mutable solution</a></h2>
<p>In the earlier approach, the sliding windows were completely independent of one another, which made it immutable, but
as I’ve also mentioned – pretty inefficient.</p>
<p>By calculating the product of 13 elements, we were performing 11 redundant multiplications in each neighboring window.</p>
<p>Instead, we can maintain a running product — dividing by the digit that leaves the window
and multiplying by the new digit that enters it. The only catch here are the zeroes that break the computation chain.</p>
<p>While this approach is definitely faster, it’s also more error-prone and harder to read.
For example, consider the following line:</p>
<pre><code class="language-scala">previous = buffer.remove(0).asDigit
</code></pre>
<p>It’s not immediately clear that <code>remove(0)</code> returns the element being removed.
Moreover, if the <code>.asDigit</code> call were omitted, the code would still compile and run,
but it would silently produce an incorrect result. For such a small task, the optimization is not worth
the effort, so treat it merely as a mental exercise.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="special-pythagorean-triplet"><a class="header" href="#special-pythagorean-triplet">Special Pythagorean Triplet</a></h1>
<p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,</p>
<p>\(a^2 + b^2 = c^2\)</p>
<p>For example \(3^2 + 4^2 = 9 + 16 = 25 = 5^2\).</p>
<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.</p>
<p>Find the product abc.</p>
<h2 id="solution-8"><a class="header" href="#solution-8">Solution</a></h2>
<p>The numbers are low enough for a naive approach, so let’s use it, while keeping the code nice and clean.</p>
<p>We need to check all combinations of a, b, c for which a + b + c = 1000 and find those that form a
Pythagorean triplet.</p>
<p>This naive algorithm starts from the highest possible ‘c’, keeps the sum of parameters at 1000, while gradually
incrementing ‘b’ and decrementing ‘c’ until this it’s possible. This condition (b == c - 2 || b == c - 1) indicates
that the next triangle can’t be created this way, so we need to increase the ‘a’ instead, while resetting the other
two parameters: ‘b’ to the lowest possible one, ‘c’ to whatever will give a sum of 1000.</p>
<p>It uses a LazyList which does keeps all the previous elements in memory. That’s not something we need, but it makes
the code pretty concise. Let’s also try a mutable approach.</p>
<pre><code class="language-scala">object Euler009 extends EulerApp {
  override def execute(): Any = {
    triangles.dropWhile(!isPythagorean(_)).head.product
  }

  type Triangle = (Int, Int, Int)
  val triangles: LazyList[Triangle] = triangles(1, 2, 997)

  private def triangles(a: Int, b: Int, c: Int): LazyList[Triangle] = {
    (a, b, c) #:: {
      if (b == c - 2 || b == c - 1) triangles(a + 1, a + 2, 997 - (2 * a))
      else triangles(a, b + 1, c - 1)
    }
  }

  private def isPythagorean(triangle: Triangle): Boolean = {
    val Triangle(a, b, c) = triangle
    a * a + b * b == c * c
  }

  extension (t: Triangle) {
    def product: Int = t._1 * t._2 * t._3
  }
}
</code></pre>
<h2 id="mutable-solution-1"><a class="header" href="#mutable-solution-1">Mutable solution</a></h2>
<p>This time let’s aim for maximum efficiency. Even though the idiomatic solution found the solution pretty fast
on my machine, the optimized one is about 10 to 15 times faster, even though they share the same algorithm.</p>
<p>It’s also more concise. It looks rather enigmatic, which is the usual pitfalls for the optimized solutions, but
in this case the difference in performance was quite substantial.</p>
<pre><code class="language-scala">object Euler009M extends EulerApp {
  override def execute(): Any = {
    var a = 1
    var b = 2
    var c = 997
    var found = false

    while (!found) {
      if (a * a + b * b == c * c) found = true
      else {
        if (b == c - 1 || b == c - 2) {
          a = a + 1
          b = a + 1
          c = 1000 - b - a
        } else {
          b = b + 1
          c = c - 1
        }
      }
    }

    a * b * c
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="summation-of-primes"><a class="header" href="#summation-of-primes">Summation of Primes</a></h1>
<p>The sum of the primes below \(10\) is \(2 + 3 + 5 + 7 = 17\).</p>
<p>Find the sum of all the primes below two million.</p>
<h2 id="solution-9"><a class="header" href="#solution-9">Solution</a></h2>
<p>We could use the brute-force method to check all the numbers up to two million, one by one, to see if they’re primes,
exactly how we did that before.</p>
<p>It would eventually finish, because we don’t run out of memory, but we wouldn’t learn anything useful this way.</p>
<p>This is the perfect problem to use the sieve of Eratosthenes. If you’ve never heard about it, then I
suggest looking it up, as it will be used in the future problems as
well: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</p>
<p>Unfortunately, the sieve itself doesn’t go along well with immutable data structures because its creation is done
iteratively, by small incremental changes. This time I’ll only present a mutable version.</p>
<p>In this solution, we’re filling the sieve, which initially considers all numbers to be primes (true) and marks the
multiples of existing primes as non-primes (false). Once we hit next number, we know that if its factors were not
found already, then it’s a prime. No need for any another check!</p>
<p>While filling the sieve, we’ll also calculate the <code>primeSum</code> to avoid iterating the array again.
It makes it even more mutable with a global state, but also faster.</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler010M extends EulerApp {
  private type Sieve = Array[Boolean]

  private val limit = 2_000_000
  private val sieve = Array(false, false) ++ Array.fill(limit - 2)(true)
  private var primeSum = 0L

  override def execute(): Long = {
    fillSieve(2)
    primeSum
  }

  @tailrec
  private def fillSieve(n: Int): Sieve = {
    if (n == limit) sieve
    else if (sieve(n)) {
      primeSum += n
      sieveWithNewPrime(n)
      fillSieve(n + 1)
    } else fillSieve(n + 1)
  }

  private def sieveWithNewPrime(newPrime: Int): Unit = {
    var nonPrime = newPrime * 2
    // We will mark all the multiplies of the new prime number, up to 'limit' as non primes
    while (nonPrime &lt; limit) {
      sieve(nonPrime) = false
      nonPrime = nonPrime + newPrime
    }
  }
}
</code></pre>
<p>We could also cut the numbers of elements stored by twice if we don’t check the even numbers, we know that they are
not primes, but that would make the solution more complex. We could also use a more memory-efficient structure, such
as BitSet, which requires 1 bit to store 1 number, as compared to array of booleans where we need 1 byte to store a
boolean. It would also increase the complexity, since BitSets are a bit more tricky to handle. Could also decrease
the performance, but I haven’t checked that.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="largest-product-in-a-grid"><a class="header" href="#largest-product-in-a-grid">Largest Product in a Grid</a></h1>
<p>In the \(20 × 20\) grid below, four numbers along a diagonal line have been marked in red.</p>
<p style="text-align: center;">
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
32 98 81 28 64 23 67 10 <span style="color: #a00;"><b>26</b></span> 38 40 67 59 54 70 66 18 38 64 70<br>
67 26 20 68 02 62 12 20 95 <span style="color: #a00;"><b>63</b></span> 94 39 63 08 40 91 66 49 94 21<br>
24 55 58 05 66 73 99 26 97 17 <span style="color: #a00;"><b>78</b></span> 78 96 83 14 88 34 89 63 72<br>
21 36 23 09 75 00 76 44 20 45 35 <span style="color: #a00;"><b>14</b></span> 00 61 33 97 34 31 33 95<br>
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br></p>

<p>The product of these numbers is \(26 × 63 × 78 × 14 = 1788696\).</p>
<p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally)
in the \(20 × 20\) grid?</p>
<h2 id="solution-10"><a class="header" href="#solution-10">Solution</a></h2>
<p>This large blocks of numbers may look daunting, but in reality the number of cases we have to check is pretty small.
It’s small enough that we can check all of them and then take the maximum.</p>
<p>First, we’ll load the data line by line and then create a 2d array of integers that represents the problem data set:</p>
<pre><code class="language-scala">def prepareData(): Array[Array[Int]] =
  loadFileAsLines().map(_.split(" ").map(_.toInt)).toArray
</code></pre>
<p>The <code>loadFileAsLines()</code> is a helper method that does exactly what its name says: it loads the file as a list of strings,
where each string is a line.</p>
<p>Let’s define our search function like that:</p>
<pre><code class="language-scala">private def findLargestProduct(matrix: Array[Array[Int]]): Long = ???
</code></pre>
<p>Because of how the data was loaded, <code>matrix(0)</code> would return the first row, and <code>matrix(0)(0)</code> will give us the first
element within the first row.</p>
<p>So, we can iterate over all the elements like that:</p>
<pre><code class="language-scala">for (col &lt;- matrix.indices; row &lt;- matrix(col).indices)
</code></pre>
<p>The <code>.indices</code> method is pretty convenient as it returns a range that corresponds to the array length, so we don’t
need to worry about going out of bounds.</p>
<p>If we’re at the element of (0, 0), then naturally we can only check the product in three directions: down,
right and diagonally (right, down). If we’re going from left to right, do we ever need to check the left direction?</p>
<p>Not really. Because if we’re checking the right direction at (0, 0), it will be the same as checking the left direction
at (0, 3). In both cases we’re multiplying these elements: (0, 0), (0, 1), (0, 2), (0, 3).</p>
<p>Likewise, when checking the diagonals, we can check only those going down. Overall, this gives us four directions
to check: “right”, “down”, “right-down”, “left-down”.</p>
<p>Checking each direction is a matter of defining right constraints, so we don’t go out of bounds. Let’s analyze how
would that look for the “right” direction.</p>
<p>First, we need to define a condition: <code>col &lt; matrix(row).length - 3</code>. The <code>matrix(row).length</code> returns the length of
the first row. We could as well define a constant of 20, but let’s keep it dynamic as a good practice. With this
check, we’re making sure that the last column we’re checking will be 16, so we can check elements 16, 17, 18, 19.
Our array has 20 elements, but they’re indexed from 0, so the last element has index 19.</p>
<p>Let’s summarize it then. Our check for the “right” direction will look as follows:</p>
<pre><code class="language-scala">var max: Long = 0
if (col &lt; matrix(row).length - 3) {
   max = Math.max(max, matrix(row)(col) * matrix(row)(col + 1) * matrix(row)(col + 2) * matrix(row)(col + 3))
}
</code></pre>
<p>Now we just need to define the checks for other 3 directions and that’s it, we’ll have our solution.</p>
<p>Here’s the complete solution. It’s a mutable one, but just a little bit. We maintain a mutable, local <code>max</code> that keeps
the maximum product we’ve found so far.</p>
<pre><code class="language-scala">object Euler011M extends EulerApp {

  override def execute(): Long = findLargestProduct(prepareData())

  def prepareData(): Array[Array[Int]] =
    loadFileAsLines().map(_.split(" ").map(_.toInt)).toArray

  private def findLargestProduct(matrix: Array[Array[Int]]): Long = {
    var max: Long = 0

    for (col &lt;- matrix.indices; row &lt;- matrix(col).indices) {
      if (row &lt; matrix.length - 3) {
        max = Math.max(max, matrix(row)(col) * matrix(row + 1)(col) * matrix(row + 2)(col) * matrix(row + 3)(col))
      }

      if (col &lt; matrix(row).length - 3) {
        max = Math.max(max, matrix(row)(col) * matrix(row)(col + 1) * matrix(row)(col + 2) * matrix(row)(col + 3))
      }

      if ((col &lt; matrix(row).length - 3) &amp;&amp; (row &gt; 3)) {
        max = Math.max(
          max,
          matrix(row)(col) * matrix(row - 1)(col + 1) * matrix(row - 2)(col + 2) * matrix(row - 3)(col + 3)
        )
      }

      if ((col &lt; matrix(row).length - 3) &amp;&amp; (row &lt; matrix.length - 3)) {
        max = Math.max(
          max,
          matrix(row)(col) * matrix(row + 1)(col + 1) * matrix(row + 2)(col + 2) * matrix(row + 3)(col + 3)
        )
      }
    }

    max
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="highly-divisible-triangular-number"><a class="header" href="#highly-divisible-triangular-number">Highly Divisible Triangular Number</a></h1>
<p>The sequence of triangle numbers is generated by adding the natural numbers. So the \(7^{th}\) triangle number would
be
\(1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\). The first ten terms would be:</p>
<p>\begin{align} 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 \end{align}</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<p>\begin{align}
\mathbf 1 &amp;\colon 1\\
\mathbf 3 &amp;\colon 1,3\\
\mathbf 6 &amp;\colon 1,2,3,6\\
\mathbf{10} &amp;\colon 1,2,5,10\\
\mathbf{15} &amp;\colon 1,3,5,15\\
\mathbf{21} &amp;\colon 1,3,7,21\\
\mathbf{28} &amp;\colon 1,2,4,7,14,28
\end{align}</p>
<p>We can see that \(28\) is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>
<h2 id="solution-11"><a class="header" href="#solution-11">Solution</a></h2>
<p>Generating the triangle numbers is very easy. The real challenge is to find the number of divisors in an efficient way.</p>
<p>The naive method wouldn’t work. You can try it, but it will take too long to finish, because the number that has 500
divisors will be quite large.</p>
<p>Any number can be represented as a product of prime factors. For example, \(28\) is \(2^2 × 7^1\).</p>
<p>We can get these factors by dividing the 28 by its prime factors:</p>
<p>\begin{align}
28 ÷ 2 = 14\\
14 ÷ 2 = 7\\
7 ÷ 7 = 1\\
\end{align}</p>
<p>The next interesting thing is, that if we take increase those factors by one and multiply them with each other, we’ll
get a total number of factors: \((2+1)(1+1) = 6\).</p>
<p>We can leverage those facts to quickly find the number of divisors, the only thing we need is a list of primes to use.</p>
<p>Let’s assume that our number will fit as a regular integer, in that case, we can get all primes like that:</p>
<pre><code class="language-scala">  private val primes: Seq[Int] =
  (2 to Math.sqrt(Integer.MAX_VALUE).toInt)
    .filter(EulerHelper.naiveIsPrime)
</code></pre>
<p>We could also use a sieve of Eratosthenes here, but let’s keep it simple instead.</p>
<p>Getting next triangle numbers is easy, we can do it with a simple recursive function that keeps the current triangle
number as <code>n</code> and the addend that was used to create it as <code>k</code>. Each iteration we increase <code>k</code> by one and calculate
<code>n</code> from <code>n + k</code>.</p>
<pre><code class="language-scala">  @tailrec
private def findTriangleNumber(n: Int = 1, k: Int = 2): Int =
  if (divisors(n) &gt; 500) n
  else findTriangleNumber(n + k, k + 1)
</code></pre>
<p>The missing part is to implement the <code>divisors(n)</code> function that calculates the number of divisors of <code>n</code>.</p>
<p>We’ve already discussed the algorithm, let’s think about the method signature:</p>
<pre><code class="language-scala">  @tailrec
private def divisors(
                      n: Int,
                      primes: Seq[Int] = primes,
                      divisorsFound: Map[Int, Int] = Map.empty
                    ): Int 
</code></pre>
<ul>
<li><code>n</code> is the number</li>
<li><code>primes</code> is a sequence of primes, initially all of them</li>
<li><code>divisorsFound</code> is how we can represent the prime factors. Map key is a prime, and value is a factor.</li>
<li>the return value is the number of divisors</li>
</ul>
<p>Let’s take a look at the whole solution:</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler012 extends EulerApp {
  override def execute(): Any = findTriangleNumber()

  private val primes: Seq[Int] =
    (2 to Math.sqrt(Integer.MAX_VALUE).toInt)
      .filter(EulerHelper.naiveIsPrime)

  @tailrec
  private def findTriangleNumber(n: Int = 1, k: Int = 2): Int =
    if (divisors(n) &gt; 500) n
    else findTriangleNumber(n + k, k + 1)

  @tailrec
  private def divisors(
      n: Int,
      primes: Seq[Int] = primes,
      divisorsFound: Map[Int, Int] = Map.empty
  ): Int = {
    val prime = primes.head

    if (n % prime == 0) {
      val newFactor = divisorsFound.get(prime) match {
        case Some(factor) =&gt; factor + 1
        case None         =&gt; 1
      }
      divisors(
        n / prime,
        primes,
        divisorsFound + (prime -&gt; newFactor)
      )
    } else if (prime &gt; n) divisorsFound.foldLeft(1) { case (accumulator, (_, factor)) =&gt;
      accumulator * (factor + 1)
    }
    else divisors(n, primes.tail, divisorsFound)
  }

}
</code></pre>
<p>It covers three cases:</p>
<pre><code class="language-scala">if (n % prime == 0)
</code></pre>
<p>This condition is met when we’re processing a prime that can divide a number.
It will result in the <code>divisorsFound</code> being updated.</p>
<pre><code class="language-scala">else if (prime &gt; n) 
</code></pre>
<p>If we hit a prime that’s higher or equal than n, then it’s time to calculate the divisors
based on the <code>divisorsFound</code> map. Keep in mind that <code>n</code> decreases every time we find a new divisor.</p>
<p>In fact, we could also use a <code>(n == 1)</code> condition here.</p>
<pre><code class="language-scala">else divisors(n, primes.tail, divisorsFound)
</code></pre>
<p>If previous conditions are both false, then it means that we simply need to check the next prime, because the current
one is not a divisor and we’re not finished yet.</p>
<h2 id="closing-notes"><a class="header" href="#closing-notes">Closing notes</a></h2>
<p>The solution is functional, it doesn’t mutate any of the collections it uses, but despite that it’s still pretty fast.</p>
<p>Obviously it could be faster, if, for example, instead of calling the <code>primes.tail</code> every time we want to move to the
next prime number we simply maintained an index of which prime we’re processing.</p>
<p>Likewise, creating a new <code>divisorsFound</code> map after every change will be less efficient than reusing a single map
and mutating it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="large-sum"><a class="header" href="#large-sum">Large Sum</a></h1>
<p>Work out the first ten digits of the sum of the following one-hundred-digit numbers.</p>
<div style="text-align: center !important; font-family: &#39;Consolas&#39;, &#39;Courier New&#39;, monospace;">
37107287533902102798797998220837590246510135740250<br>
46376937677490009712648124896970078050417018260538<br>
74324986199524741059474233309513058123726617309629<br>
91942213363574161572522430563301811072406154908250<br>
23067588207539346171171980310421047513778063246676<br>
89261670696623633820136378418383684178734361726757<br>
28112879812849979408065481931592621691275889832738<br>
44274228917432520321923589422876796487670272189318<br>
47451445736001306439091167216856844588711603153276<br>
70386486105843025439939619828917593665686757934951<br>
62176457141856560629502157223196586755079324193331<br>
64906352462741904929101432445813822663347944758178<br>
92575867718337217661963751590579239728245598838407<br>
58203565325359399008402633568948830189458628227828<br>
80181199384826282014278194139940567587151170094390<br>
35398664372827112653829987240784473053190104293586<br>
86515506006295864861532075273371959191420517255829<br>
71693888707715466499115593487603532921714970056938<br>
54370070576826684624621495650076471787294438377604<br>
53282654108756828443191190634694037855217779295145<br>
36123272525000296071075082563815656710885258350721<br>
45876576172410976447339110607218265236877223636045<br>
17423706905851860660448207621209813287860733969412<br>
81142660418086830619328460811191061556940512689692<br>
51934325451728388641918047049293215058642563049483<br>
62467221648435076201727918039944693004732956340691<br>
15732444386908125794514089057706229429197107928209<br>
55037687525678773091862540744969844508330393682126<br>
18336384825330154686196124348767681297534375946515<br>
80386287592878490201521685554828717201219257766954<br>
78182833757993103614740356856449095527097864797581<br>
16726320100436897842553539920931837441497806860984<br>
48403098129077791799088218795327364475675590848030<br>
87086987551392711854517078544161852424320693150332<br>
59959406895756536782107074926966537676326235447210<br>
69793950679652694742597709739166693763042633987085<br>
41052684708299085211399427365734116182760315001271<br>
65378607361501080857009149939512557028198746004375<br>
35829035317434717326932123578154982629742552737307<br>
94953759765105305946966067683156574377167401875275<br>
88902802571733229619176668713819931811048770190271<br>
25267680276078003013678680992525463401061632866526<br>
36270218540497705585629946580636237993140746255962<br>
24074486908231174977792365466257246923322810917141<br>
91430288197103288597806669760892938638285025333403<br>
34413065578016127815921815005561868836468420090470<br>
23053081172816430487623791969842487255036638784583<br>
11487696932154902810424020138335124462181441773470<br>
63783299490636259666498587618221225225512486764533<br>
67720186971698544312419572409913959008952310058822<br>
95548255300263520781532296796249481641953868218774<br>
76085327132285723110424803456124867697064507995236<br>
37774242535411291684276865538926205024910326572967<br>
23701913275725675285653248258265463092207058596522<br>
29798860272258331913126375147341994889534765745501<br>
18495701454879288984856827726077713721403798879715<br>
38298203783031473527721580348144513491373226651381<br>
34829543829199918180278916522431027392251122869539<br>
40957953066405232632538044100059654939159879593635<br>
29746152185502371307642255121183693803580388584903<br>
41698116222072977186158236678424689157993532961922<br>
62467957194401269043877107275048102390895523597457<br>
23189706772547915061505504953922979530901129967519<br>
86188088225875314529584099251203829009407770775672<br>
11306739708304724483816533873502340845647058077308<br>
82959174767140363198008187129011875491310547126581<br>
97623331044818386269515456334926366572897563400500<br>
42846280183517070527831839425882145521227251250327<br>
55121603546981200581762165212827652751691296897789<br>
32238195734329339946437501907836945765883352399886<br>
75506164965184775180738168837861091527357929701337<br>
62177842752192623401942399639168044983993173312731<br>
32924185707147349566916674687634660915035914677504<br>
99518671430235219628894890102423325116913619626622<br>
73267460800591547471830798392868535206946944540724<br>
76841822524674417161514036427982273348055556214818<br>
97142617910342598647204516893989422179826088076852<br>
87783646182799346313767754307809363333018982642090<br>
10848802521674670883215120185883543223812876952786<br>
71329612474782464538636993009049310363619763878039<br>
62184073572399794223406235393808339651327408011116<br>
66627891981488087797941876876144230030984490851411<br>
60661826293682836764744779239180335110989069790714<br>
85786944089552990653640447425576083659976645795096<br>
66024396409905389607120198219976047599490197230297<br>
64913982680032973156037120041377903785566085089252<br>
16730939319872750275468906903707539413042652315011<br>
94809377245048795150954100921645863754710598436791<br>
78639167021187492431995700641917969777599028300699<br>
15368713711936614952811305876380278410754449733078<br>
40789923115535562561142322423255033685442488917353<br>
44889911501440648020369068063960672322193204149535<br>
41503128880339536053299340368006977710650566631954<br>
81234880673210146739058568557934581403627822703280<br>
82616570773948327592232845941706525094512325230608<br>
22918802058777319719839450180888072429661980811197<br>
77158542502016545090413245809786882778948721859617<br>
72107838435069186155435662884062257473692284509516<br>
20849603980134001723930671666823555245252804609722<br>
53503534226472524250874054075591789781264330331690<br>
</div>

<h2 id="solution-12"><a class="header" href="#solution-12">Solution</a></h2>
<p>That’s a lot of long numbers! Fortunately for us, the standard library in Scala makes this task very easy.
Code should be self-explanatory, there isn’t much to add.</p>
<pre><code class="language-scala">object Euler013 extends EulerApp {
  override def execute(): String =
    loadFileAsLines().map(BigInt.apply).sum.toString().take(10)
}
</code></pre>
<p>The <code>loadFileAsLines()</code> loads the numbers from a text file, lime by line.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="longest-collatz-sequence"><a class="header" href="#longest-collatz-sequence">Longest Collatz Sequence</a></h1>
<p>The following iterative sequence is defined for the set of positive integers:</p>
<p>\(n \to n/2\) (\(n\) is even)&lt;\br&gt;
\(n \to 3n + 1\) (\(n\) is odd)</p>
<p>Using the rule above and starting with \(13\), we generate the following sequence:
\begin{align}
13 \to 40 \to 20 \to 10 \to 5 \to 16 \to 8 \to 4 \to 2 \to 1.
\end{align}</p>
<p>It can be seen that this sequence (starting at \(13\) and finishing at \(1\)) contains \(10\) terms.
Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at \(1\).</p>
<p>Which starting number, under one million, produces the longest chain?</p>
<p><strong>NOTE:</strong> Once the chain starts the terms are allowed to go above one million.</p>
<h2 id="solution-13"><a class="header" href="#solution-13">Solution</a></h2>
<p>Let’s make aa brute-force solution and see how it works.</p>
<p>We can add one optimization that cuts the execution time in half. Due to how the sequences are calculated,
a collatzLength(2n) is always bigger than collatzLength(n) by 1.</p>
<p>So, we can check only the upper half of the range to get the maximum length of the sequence. Here’s the code.</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler014 extends EulerApp {

  override def execute(): Any = (500_000 until 1_000_000).maxBy(collatzLength)

  private def collatzLength(n: Int): Int = {
    @tailrec
    def collatzLength(n: Long, currentLength: Int): Int = n match {
      case 1               =&gt; currentLength + 1
      case n if n % 2 == 0 =&gt; collatzLength(n / 2, currentLength + 1)
      case n               =&gt; collatzLength(n * 3 + 1, currentLength + 1)
    }

    collatzLength(n, 0)
  }
}
</code></pre>
<p>My first though when seeing this problem was to use the dynamic programming. After all, we’ll keep hitting the same
sub-sequences (such as 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1) many times.</p>
<p>I implemented it using a map while keeping it immutable, but it wasn’t a great idea.
The code ran much slower. In fact, even with a mutable map it was around 50% slower than the brute-force one.</p>
<p>Often it’s worth starting out from a basic solution. This way there’s less room for mistake,
and we have a baseline result that we can improve further.</p>
<h2 id="mutable-solution-2"><a class="header" href="#mutable-solution-2">Mutable solution</a></h2>
<p>Let’s think for a while how can we improve the brute-force solution.</p>
<p>As I’ve mentioned, some operations are done multiple times. We can memoize them, in an array-based cache for
fast lookups. Why array? Because map would be much slowe, and we know its max size.</p>
<p>In fact, we don’t have to cache all the values. You can try it out yourself by limiting the <code>cacheLimit</code>: to 100_000.
It should be slower, but still faster than the brute-force solution.</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler014M extends EulerApp {

  override def execute(): Any = (1 until 1_000_000).maxBy(collatzLength)

  private val cacheLimit = 1_000_000
  private val cache = new Array[Int](cacheLimit)
  cache(1) = 1

  private def collatzLength(base: Int): Int = {
    @tailrec
    def compute(n: Long, length: Int): Int = {
      if (n &lt; cacheLimit &amp;&amp; cache(n.toInt) != 0) {
        length + cache(n.toInt)
      } else if (n % 2 == 0) {
        compute(n / 2, length + 1)
      } else {
        compute(n * 3 + 1, length + 2)
      }
    }

    val result = compute(base, 0)
    if (base &lt; cacheLimit) cache(base) = result
    result
  }
}
</code></pre>
<p>As you see we get rid of the optimization to start from 500_000. That’s because, it turns out, it works slightly
slower than starting from the beginning, because our cache has a lot of misses this way, and we don’t backtrace the
values to fill it.</p>
<p>We could try to do it, but is it worth increasing the complexity of the solution even further, if it already runs in
milliseconds? Sometimes it is, but here, I’ll pass.</p>
<h2 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h2>
<p>If it wasn’t a computational problem, but a business-oriented one, then the base, immutable solution would be the one
preferred in almost all the cases, due to how simple and safe it is.</p>
<p>The mutable solution has much more places where errors can be made. For example, the ‘n.toInt’ is only safe because we
check right before that n is below a cache limit, which prevents the overflow.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lattice-paths"><a class="header" href="#lattice-paths">Lattice Paths</a></h1>
<p>Starting in the top left corner of a \(20 \times 20\) grid, and only being able to move to the right and down,
there are exactly \(6\) routes to the bottom right corner.</p>
<p><img src="assets/0015.png" alt="paths"></p>
<p>How many such routes are there through a \(20 \times 20\) grid?</p>
<h2 id="lets-make-it-easier-1"><a class="header" href="#lets-make-it-easier-1">Let’s make it easier</a></h2>
<p>When I saw this problem for the first time my first thought was that I probably can calculate it with a pen and paper.</p>
<p>But since we’re coding in Scala here, let’s try to make an application that will solve it for us.</p>
<p>\(20 \times 20\) is a big array, too big to reason about it, while the \(2 \times 2\) is a bit too small. Let’s
then draw a \(3 \times 3\) one and mark the edges with dots. How many ways to we have to reach each of these dots?
Exactly one way. That was the easiest part.</p>
<div style="max-width: fit-content; margin-inline: auto;">
<img src="assets/0015-1.png" style="height:150px">
</div>

<p>Now let’s try a second row. If we know how to get to the dot above and to the dot on the left side, then we also know
how to go to the dot in question, because from their positions there’s just one way to continue (either left or down).</p>
<p>So, we can fill the second row starting from the left side. First dot will be \(1 + 1 = 2\), second will be
\(3 + 1 = 3\), third one will be \(3 + 1 = 4\)</p>
<div style="max-width: fit-content; margin-inline: auto;">
<img src="assets/0015-2.png" style="height:150px">
</div>

<p>The third row will be no different, let’s continue the process:</p>
<div style="max-width: fit-content; margin-inline: auto;">
<img src="assets/0015-3.png" style="height:150px">
</div>

<p>And the same goes for the last one. The answer to a question in how many possible ways we can reach the last lattice
can be found in the bottom right corner: 20.</p>
<div style="max-width: fit-content; margin-inline: auto;">
<img src="assets/0015-4.png" style="height:150px">
</div>

<h2 id="solution-14"><a class="header" href="#solution-14">Solution</a></h2>
<p>The previous section shown us some properties of the lattice paths. We can now implement the algorithm that we used.
I went for a functional, recursive solution, but a mutable one that’s based on a simple 2-dimensional <code>Array</code> could do as well.</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler015 extends EulerApp {
  override def execute(): Long = countLatticePaths(21, 21)

  private def countLatticePaths(length: Int, height: Int): Long = {
    val lattice = fillLatticeArray(length, height)
    lattice(length - 1)(height - 1)
  }

  @tailrec
  private def fillLatticeArray(length: Int, height: Int, currentResult: Seq[Seq[Long]] = Seq.empty): Seq[Seq[Long]] =
    currentResult match {
      // First row, we'll fill it with ones
      case Nil =&gt;
        fillLatticeArray(
          length,
          height,
          Seq(Seq.fill(length)(1L))
        )
      // All rows filled, time to finish
      case other if other.size == height =&gt; currentResult
      // Filling the next row, but not the first one
      case other =&gt;
        val nextRowNum = currentResult.size
        val previousRow = currentResult(nextRowNum - 1)
        fillLatticeArray(
          length,
          height,
          currentResult :+ previousRow.foldLeft(List.empty) { case (result, previousRowNum) =&gt;
            result :+ result.lastOption.getOrElse(0L) + previousRowNum
          }
        )
    }
}
</code></pre>
<p>It does exactly what we did manually, but on a larger scale. It fills the first row and first column with ones, and then
it calculates next elements from left to right, top to bottom. The answer is, as before, in the bottom right corner.</p>
<p>It’s a bit robust, but works pretty fast. What could you improve there?</p>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>Before continuing, think about how can we improve the solution.
Can we make it more memory efficient? Can we make it faster? Do we calculate something that’s not needed for the answer?</p>
</blockquote>
<h2 id="mutable-solution-3"><a class="header" href="#mutable-solution-3">Mutable solution</a></h2>
<p>It’s not a surprise that making it mutable will make it faster. Just keep in mind that in non-algorithmic tasks the
performance gainst might be miniscule, completely outweighed by all the downsides of making it mutable.</p>
<p>So, the first change would be to switch the <code>Seq</code> to an <code>Array</code>. What else can we do?</p>
<p>Previously, we stored all the intermediate results and created a complete, large array with all the values. In fact,
we can calculate the next row knowing the previous row. We don’t need to remember all the other ones. Which means that
there’s no need to maintain a 2-dimensional <code>Array</code>.</p>
<p>My first thought was that we need two arrays, for the current and the previous row. Can we use just one?</p>
<p>In the example with four lattices, the second row contained the following values: \(1, 2, 3, 4\)</p>
<p>If we wanted to calculate the third row by mutating the \(1, 2, 3, 4\) one, then:</p>
<ul>
<li>Nothing changes for the first element. It stays as one.</li>
<li>We add the previous element to the next element, that is, \(1 + 2\), and the second element is \(3\). Our row is now \(1, 3, 3, 4\).</li>
<li>We do the same for the third element, our row is now \(1, 3, 6, 4\)</li>
<li>And the last element is calculated with \(6 + 4 = 10\), the row is now equal to \(1, 3, 6, 10\)</li>
<li>For the next row, we do the same again. \(1\) stays unchanged, the second number if \(4\), another one is \(9\), and so on…</li>
</ul>
<p>In short, now we only need to keep one row in the memory. Here’s the implementation:</p>
<pre><code class="language-scala">object Euler015M extends EulerApp {
  override def execute(): Long = countLatticePaths(21, 21)

  private def countLatticePaths(length: Int, height: Int): Long = {
    val prevRow = Array.fill(length)(1L)

    for (_ &lt;- 1 until height) {
      for (col &lt;- 1 until length) {
        prevRow(col) += prevRow(col - 1)
      }
    }

    prevRow(length - 1)
  }
}
</code></pre>
<h2 id="epilogue-1"><a class="header" href="#epilogue-1">Epilogue</a></h2>
<p>Going forward, we could also use this finding to improve the original, immutable solution. But maybe there’s
no need to run this iterative computation at all? If you look at those numbers, they seem to be following a
certain pattern.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="power-digit-sum"><a class="header" href="#power-digit-sum">Power Digit Sum</a></h1>
<p>\(2^{15} = 32768\) and the sum of its digits is \(3 + 2 + 7 + 6 + 8 = 26\).</p>
<p>What is the sum of the digits of the number \(2^{1000}\)?</p>
<h2 id="solution-15"><a class="header" href="#solution-15">Solution</a></h2>
<p>Due to the rich standard library in Scala, this problem is extremely easy. We can solve it in one line only!</p>
<pre><code class="language-scala">object Euler016 extends EulerApp {
  override def execute(): Int = (BigInt(2) ^ 1000).toString().map(_.asDigit).sum
}
</code></pre>
<p>It even runs very fast. If we wanted to avoid using <code>BigInt</code>, then it wouldn’t be much harder. We could store the
individual digits in an array and each multiplication would double all the indexes by two. We’d also need to handle
the carrying over.</p>
<p>Still pretty straightforward, not really worth the effort to go through it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="number-letter-counts"><a class="header" href="#number-letter-counts">Number Letter Counts</a></h1>
<p>If the numbers \(1\) to \(5\) are written out in words: one, two, three, four, five, then there are
\(3 + 3 + 5 + 4 + 4 = 19\) letters used in total.</p>
<p>If all the numbers from \(1\) to \(1000\) (one thousand) inclusive were written out in words,
how many letters would be used?</p>
<p><strong>Note:</strong> Do not count spaces or hyphens. For example, \(342\) (three hundred and forty-two) contains \(23\)
letters and \(115\) (one hundred and fifteen) contains \(20\) letters.
The use of “and” when writing out numbers is in compliance with British usage.</p>
<h2 id="solution-16"><a class="header" href="#solution-16">Solution</a></h2>
<p>Well, that’s a lot of numbers to cover. Let’s start with something easy, changing one-digit numbers to strings:</p>
<pre><code class="language-scala">private def writeDigit(i: Int): String = i match {
  case 0 =&gt; "zero"
  case 1 =&gt; "one"
  case 2 =&gt; "two"
  case 3 =&gt; "three"
  case 4 =&gt; "four"
  case 5 =&gt; "five"
  case 6 =&gt; "six"
  case 7 =&gt; "seven"
  case 8 =&gt; "eight"
  case 9 =&gt; "nine"
  case _ =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
}
</code></pre>
<p>Plenty of code, but it’s very straightforward. We could make it more concise by using an <code>Array</code>, but I like this very
explicit pattern match. What’s next? We can write numbers from 10 to 19:</p>
<pre><code class="language-scala">private def writeTenToNineteen(i: Int): String = i match {
  case 10 =&gt; "ten"
  case 11 =&gt; "eleven"
  case 12 =&gt; "twelve"
  case 13 =&gt; "thirteen"
  case 14 =&gt; "fourteen"
  case 15 =&gt; "fifteen"
  case 16 =&gt; "sixteen"
  case 17 =&gt; "seventeen"
  case 18 =&gt; "eighteen"
  case 19 =&gt; "nineteen"
  case _  =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
}
</code></pre>
<p>There’s not much to simplify there yet, because too many words are irregular. 17 is regular, it consists of
“seven” + “teen”, so it might seem appealing to pick the last digit to form a prefix, and add “teen” as a suffix, but
due to the fact that it’s not very regular, we’d end up with such oddities as 11 represented as “oneteen” :)</p>
<p>Higher numbers, fortunately, are much more regular. For all the numbers between 20 and 99, we can separate the last
digit from those numbers, convert it to a string using the previously defined <code>writeDigit</code> function, and append it
to a string representation of the two-digit number like 20 or 30. Finally, we can reuse some of our previous functions.</p>
<p>If the number is divisible by 10, then we don’t need the output of <code>writeDigit</code>, or we’ll end up with numbers like
20 being written out as “twenty-zero”.</p>
<pre><code class="language-scala">private def writeTens(i: Int): String = {
  val remainder = i % 10
  val maybeRemainder = if (remainder != 0) Some(writeInt(remainder)) else None
  val tens = i - remainder match {
    case 20 =&gt; "twenty"
    case 30 =&gt; "thirty"
    case 40 =&gt; "forty"
    case 50 =&gt; "fifty"
    case 60 =&gt; "sixty"
    case 70 =&gt; "seventy"
    case 80 =&gt; "eighty"
    case 90 =&gt; "ninety"
    case _  =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
  }
  
  maybeRemainder match {
    case Some(digits) =&gt; s"$tens-$digits"
    case None         =&gt; tens
  }
}
</code></pre>
<p>What’s <code>writeInt</code> in the code above? It’s a function that writes any int. That’s where we put the guards not to pass
the int into a function that wouldn’t be able to process it. Right now it looks like that:</p>
<pre><code class="language-scala">private def writeInt(i: Int): String = i match {
  case i if i &gt;= 0 &amp;&amp; i &lt; 10     =&gt; writeDigit(i)
  case i if i &gt;= 10 &amp;&amp; i &lt; 20    =&gt; writeTenToNineteen(i)
  case i if i &gt;= 20 &amp;&amp; i &lt; 100   =&gt; writeTens(i)
}
</code></pre>
<p>The last part are the hundreds. They’re the most regular, we’ll be able to reuse almost everything we’ve written so far.
A number like 123 consists of:</p>
<ul>
<li>Written digit (1), using the <code>writeDigit</code> function</li>
<li>“hundred” word</li>
<li>Written last two digits, using the <code>writeInt</code> function, since we don’t know if we should use <code>writeDigit</code>,<code>writeTenToNineteen</code> or <code>writeTens</code></li>
</ul>
<p>And here’s the code for hundreds:</p>
<pre><code class="language-scala">private def writeHundreds(i: Int): String = {
  val remainder = i % 100
  val maybeRemainder = if (remainder != 0) Some(writeInt(remainder)) else None
  val hundred = s"${writeDigit((i - remainder) / 100)} hundred"

  maybeRemainder match {
    case Some(tens) =&gt; s"$hundred and $tens"
    case None       =&gt; hundred
  }
}
</code></pre>
<p>We also need to handle 1000 as “one thousand” and we’re almost done. Here’s the complete solution that convers numbers
to strings and counts the letters:</p>
<pre><code class="language-scala">object Euler017 extends EulerApp {
  override def execute(): Any = (1 to 1000)
    .map(writeInt)
    .map(_.count(_.isLetter))
    .sum

  private def writeInt(i: Int): String = i match {
    case i if i &gt;= 0 &amp;&amp; i &lt; 10     =&gt; writeDigit(i)
    case i if i &gt;= 10 &amp;&amp; i &lt; 20    =&gt; writeTenToNineteen(i)
    case i if i &gt;= 20 &amp;&amp; i &lt; 100   =&gt; writeTens(i)
    case i if i &gt;= 100 &amp;&amp; i &lt; 1000 =&gt; writeHundreds(i)
    case 1000                      =&gt; "one thousand"
  }

  private def writeDigit(i: Int): String = i match {
    case 0 =&gt; "zero"
    case 1 =&gt; "one"
    case 2 =&gt; "two"
    case 3 =&gt; "three"
    case 4 =&gt; "four"
    case 5 =&gt; "five"
    case 6 =&gt; "six"
    case 7 =&gt; "seven"
    case 8 =&gt; "eight"
    case 9 =&gt; "nine"
    case _ =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
  }

  private def writeTenToNineteen(i: Int): String = i match {
    case 10 =&gt; "ten"
    case 11 =&gt; "eleven"
    case 12 =&gt; "twelve"
    case 13 =&gt; "thirteen"
    case 14 =&gt; "fourteen"
    case 15 =&gt; "fifteen"
    case 16 =&gt; "sixteen"
    case 17 =&gt; "seventeen"
    case 18 =&gt; "eighteen"
    case 19 =&gt; "nineteen"
    case _  =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
  }

  private def writeTens(i: Int): String = {
    val remainder = i % 10
    val maybeRemainder = if (remainder != 0) Some(writeInt(remainder)) else None
    val tens = i - remainder match {
      case 20 =&gt; "twenty"
      case 30 =&gt; "thirty"
      case 40 =&gt; "forty"
      case 50 =&gt; "fifty"
      case 60 =&gt; "sixty"
      case 70 =&gt; "seventy"
      case 80 =&gt; "eighty"
      case 90 =&gt; "ninety"
      case _  =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
    }

    maybeRemainder match {
      case Some(digits) =&gt; s"$tens-$digits"
      case None         =&gt; tens
    }
  }

  private def writeHundreds(i: Int): String = {
    val remainder = i % 100
    val maybeRemainder = if (remainder != 0) Some(writeInt(remainder)) else None
    val hundred = s"${writeDigit((i - remainder) / 100)} hundred"

    maybeRemainder match {
      case Some(tens) =&gt; s"$hundred and $tens"
      case None       =&gt; hundred
    }
  }
}
</code></pre>
<h2 id="epilogue-2"><a class="header" href="#epilogue-2">Epilogue</a></h2>
<p>Was it necessary to convert everything to a string? Not at all. We were asked to count the letters only, so if we
wanted to be more efficient, the pattern matching could look like that:</p>
<pre><code class="language-scala">case 8 =&gt; 5
</code></pre>
<p>There are \(5\) letters in the word “eight”. There’s one problem with that approach. Debugging it would be a nightmare.
It would be not reusable for anything. The program runs fast already, after all.</p>
<p>There’s one improvement that we could make, though. Those cases aren’t good:</p>
<pre><code class="language-scala">case _ =&gt; throw IllegalArgumentException(s"Received unexpected input: $i")
</code></pre>
<p>Due to them, our functions aren’t pure. They have a very nasty side effect. Even though they all accept <code>Int</code> parameter,
they can only operate on a subset of numbers. That’s a risky, error-prone design. A much better solution would use
refined types. For example, a separate <code>Digit</code> type that could be only created from numbers 0 to 9. Such types can be
also checked by compiler, so a <code>Digit(10)</code> throws a compilation error rather than a runtime exception.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="maximum-path-sum-i"><a class="header" href="#maximum-path-sum-i">Maximum Path Sum I</a></h1>
<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total
from top to bottom is \(23\).</p>
<p style="text-align: center; font-family: monospace;">
    <span style="color: #a00;"><b>3</b></span><br>
    <span style="color: #a00;"><b>7</b></span> 4<br>
    2 <span style="color: #a00;"><b>4</b></span> 6<br>
    8 5 <span style="color: #a00;"><b>9</b></span> 3
</p>

<p>That is, \(3 + 7 + 4 + 9 = 23\).</p>
<p>Find the maximum total from top to bottom of the triangle below:</p>
<p style="text-align: center; font-family: monospace;">75<br>
95 64<br>
17 47 82<br>
18 35 87 10<br>
20 04 82 47 65<br>
19 01 23 75 03 34<br>
88 02 77 73 07 63 67<br>
99 65 04 28 06 16 70 92<br>
41 41 26 56 83 40 80 70 33<br>
41 48 72 33 47 32 37 16 94 29<br>
53 71 44 65 25 43 91 52 97 51 14<br>
70 11 33 28 77 73 17 78 39 68 17 57<br>
91 71 52 38 17 14 91 43 58 50 27 29 48<br>
63 66 04 68 89 53 67 30 73 16 69 87 40 31<br>
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23</p>

<p><strong>NOTE</strong>: As there are only \(16384\) routes, it is possible to solve this problem by trying every route.
However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute
force, and requires a clever method! ;o)</p>
<h2 id="lets-make-it-easier-2"><a class="header" href="#lets-make-it-easier-2">Let’s make it easier</a></h2>
<p>We could indeed try to brute-force it, but I did not come up with any elegant brute-force in terms of implementation, so
I’ve decided to instead think about solving this problem the ‘intended way’. As usual, let’s think about a nice
algorithm that will save us from the necessity of checking all these possibilities.
The small triangle will be perfect to plan it.</p>
<p style="text-align: center; font-family: monospace;">3<br>
7 4<br>
2 4 6<br>
8 5 9 3<br>
</p>

<p>Instead of plotting a route from the top, we could try to do it from the bottom. Can we do something with the last row?
Not really. We can’t take the maximum since we don’t know what’s ahead of us, exactly as if we started from the top.</p>
<p>Moving to the row before last, that is, \(2 4 6\), we notice that each of those numbers have exactly two
children-numbers. For \(2\), that will be \(8\) and \(5\), for 4, it is \(5\) and \(9\), and so on.
If our question was to find the best path for those small sub-problems, with 3-number triangles, then naturally we’d
simply pick the bigger children. We can then add it to the parent. That’s how the triangle now looks like:</p>
<p style="text-align: center; font-family: monospace;">3<br>
7 4<br>
10 13 15<br>
</p>

<p>We can do the same folding to the next row. Just need to pick the “bigger” children. Eventually we’ll end up with that:</p>
<p style="text-align: center; font-family: monospace;">3<br>
20 19<br>
</p>

<p>And then we fold it once again, leaving us with a single value: \(23\). That’s the maximum path sum.</p>
<h2 id="solution-17"><a class="header" href="#solution-17">Solution</a></h2>
<p>For a big triangle, the algorithm remains exactly the same. A natural way to implement it is to mutate the arrays that
represent the subsequent rows.</p>
<pre><code class="language-scala">object Euler018M extends EulerApp {
  override def execute(): Int = {
    val dataArray: Array[Array[Int]] = prepareData()
    var rowIndex = dataArray.length - 2

    while (rowIndex &gt;= 0) {
      dataArray(rowIndex).zipWithIndex.foreach { case (value, columnIndex) =&gt;
        val childrenRow = dataArray(rowIndex + 1)
        val maxChildValue = Math.max(childrenRow(columnIndex), childrenRow(columnIndex + 1))
        dataArray(rowIndex)(columnIndex) = dataArray(rowIndex)(columnIndex) + maxChildValue
      }
      rowIndex -= 1
    }

    dataArray.head.head
  }

  private def prepareData(): Array[Array[Int]] =
    loadFileAsLines().toArray.map(_.split(" ").map(_.toInt).toArray)
}
</code></pre>
<p>Very straightforward to implement, as it closely follows what we did on paper with the small triangle, but
unfortunately it mutates both the <code>dataArray</code> and the <code>rowIndex</code>.</p>
<p>For an immutable solution, we need to fold our triangle from the bottom. We can represent it as a
<code>List[List[Int]]</code> and reverse it so we start from the end.</p>
<pre><code class="language-scala">val reversedData = prepareData().reverse
reversedData.tail.foldLeft(reversedData.head) { case (previousRow, currentRow) =&gt; ... }
</code></pre>
<p>This part starts from the second row (<code>.tail</code>), while the first one goes into the accumulator. Since we always have two
rows available, all we need to do is pick the bigger child and build the next accumulator, which will be our
new <code>previousRow</code>. Here’s the complete solution:</p>
<pre><code class="language-scala">object Euler018 extends EulerApp {
  override def execute(): Int = {
    val reversedData = prepareData().reverse
    reversedData.tail
      .foldLeft(reversedData.head) { case (previousRow, currentRow) =&gt;
        currentRow.zipWithIndex.map { case (element, index) =&gt;
          element + Math.max(previousRow(index), previousRow(index + 1))
        }
      }
      .head
  }

  private def prepareData(): List[List[Int]] =
    loadFileAsLines().map(_.split(" ").map(_.toInt).toList)
}
</code></pre>
<p>That’s it! Very concise, fully functional and with a similar run time.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="counting-sundays"><a class="header" href="#counting-sundays">Counting Sundays</a></h1>
<p>You are given the following information, but you may prefer to do some research for yourself.</p>
<ul>
<li>1 Jan 1900 was a Monday.</li>
<li>Thirty days has September,<br>
April, June and November.<br>
All the rest have thirty-one,<br>
Saving February alone,<br>
Which has twenty-eight, rain or shine.<br>
And on leap years, twenty-nine.</li>
<li>A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</li>
</ul>
<p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p>
<h2 id="solution-18"><a class="header" href="#solution-18">Solution</a></h2>
<p>I’m afraid there’s no clever way to solve this without writing plenty of code. On the other hand, this problem is
pretty straightforward; all we need is some domain modelling. Let’s do it then.</p>
<p>We can start by encoding some simple facts about the calendar. We need to know how many days are in a given month,
as well as if the year is leap or not. Let’s also add two helper functions to let us quickly check the century:</p>
<pre><code class="language-scala">private type Year = Int

private def daysPerMonth(year: Year): Array[Int] = Array(
  31, // January
  if (isLeapYear(year)) 29 else 28, // February
  31, // March
  30, // April
  31, // May
  30, // June
  31, // July
  31, // August
  30, // September
  31, // October
  30, // November
  31 // December
)

private def isLeapYear(year: Year): Boolean =
  (year % 4 == 0) &amp;&amp; (year % 100 != 0 || year % 400 == 0)

def isInTwentiethCentury: Boolean = year &gt;= 1901 &amp;&amp; year &lt;= 2000

def isInTwentyFirstCentury: Boolean = year &gt;= 2001
</code></pre>
<p>Having those facts laid out, we can try constructing a crude model of a calendar:</p>
<pre><code class="language-scala">case class Calendar(
     dayNumber: Int,
     dayOfWeekNumber: Int,
     monthNumber: Int,
     year: Year
 ) 
</code></pre>
<p>In this case:</p>
<ul>
<li><code>dayNumber</code> represents a number of a day in a month, as in June 10</li>
<li><code>dayOfWeekNumber</code> is an internal counter for a day of the week, 0 being Monday and 6 Sunday</li>
<li><code>monthNumber</code> is a number of the month, 0 being January</li>
<li><code>year</code> is a year type that we’ve defined before</li>
</ul>
<p>Our calendar needs a way to progress the day while keeping the state of other variables consistent.
It’s not difficult since we have some data to use. Once the <code>dayOfWeekNumber</code> reaches 7 we go back to 0.
Every time we reach a day that’s higher than the <code>daysPerMonth(year)(monthNumber)</code>, we either progress the month
or a whole year if we’re at the last month (11 on our case, since we count from 0).</p>
<p>If neither of these checks is met, we simply progress the day.</p>
<pre><code class="language-scala">def nextDay(): Calendar = {
  val newDay = dayNumber + 1
  val newDayOfWeek = if (dayOfWeekNumber + 1 == 7) 0 else dayOfWeekNumber + 1

  if (newDay &gt; daysPerMonth(year)(monthNumber)) {
    if (monthNumber == 11) Calendar(1, newDayOfWeek, 0, year + 1)
    else Calendar(1, newDayOfWeek, monthNumber + 1, year)
  } else Calendar(newDay, newDayOfWeek, monthNumber, year)
}

val dayOfWeek: DayOfWeek = daysOfWeek(dayOfWeekNumber)

val isSunday: Boolean = dayOfWeekNumber == 6
</code></pre>
<p>And that’s all we need to calculate it. The condition that we’ll be checking is pretty simple:
<code>if (calendar.isSunday &amp;&amp; calendar.dayNumber == 1)</code>
If it’s met, then we’ve found the Sunday we’re looking for. If not, we progress the calendar further, until
<code>(calendar.isInTwentyFirstCentury)</code> – that’s the termination condition.</p>
<p>Here’s the whole code:</p>
<pre><code class="language-scala">import scala.annotation.tailrec

object Euler019 extends EulerApp {

  private type DayOfWeek = String
  private type Year = Int

  override def execute(): Any = {
    @tailrec
    def sundaysInTwentyCentury(calendar: Calendar, sundays: Int): Int = {
      if (calendar.isInTwentyFirstCentury) sundays
      else if (calendar.isInTwentiethCentury) {
        val newSundays =
          if (calendar.isSunday &amp;&amp; calendar.dayNumber == 1) sundays + 1 else sundays
        sundaysInTwentyCentury(calendar.nextDay(), newSundays)
      } else sundaysInTwentyCentury(calendar.nextDay(), sundays)
    }

    sundaysInTwentyCentury(Calendar.StartDate, 0)
  }

  case class Calendar(
      dayNumber: Int,
      dayOfWeekNumber: Int,
      monthNumber: Int,
      year: Year
  ) {
    private def daysPerMonth(year: Year): Array[Int] = Array(
      31, // January
      if (isLeapYear(year)) 29 else 28, // February
      31, // March
      30, // April
      31, // May
      30, // June
      31, // July
      31, // August
      30, // September
      31, // October
      30, // November
      31 // December
    )

    private def isLeapYear(year: Year): Boolean =
      (year % 4 == 0) &amp;&amp; (year % 100 != 0 || year % 400 == 0)

    def nextDay(): Calendar = {
      val newDay = dayNumber + 1
      val newDayOfWeek = if (dayOfWeekNumber + 1 == 7) 0 else dayOfWeekNumber + 1

      if (newDay &gt; daysPerMonth(year)(monthNumber)) {
        if (monthNumber == 11) Calendar(1, newDayOfWeek, 0, year + 1)
        else Calendar(1, newDayOfWeek, monthNumber + 1, year)
      } else Calendar(newDay, newDayOfWeek, monthNumber, year)
    }

    val isSunday: Boolean = dayOfWeekNumber == 6

    def isInTwentiethCentury: Boolean = year &gt;= 1901 &amp;&amp; year &lt;= 2000

    def isInTwentyFirstCentury: Boolean = year &gt;= 2001
  }

  object Calendar {
    val StartDate: Calendar = Calendar(dayNumber = 1, dayOfWeekNumber = 0, monthNumber = 0, year = 1900)
  }
}
</code></pre>
<h2 id="mutable-solution-4"><a class="header" href="#mutable-solution-4">Mutable solution</a></h2>
<p>While reading the previous solution you might be thinking… why don’t we just use the standard library? Indeed, we can!
In fact, this problem is completely trivialized once we do so. We can simply encode the start date and the end date,
the condition is easily expressed with API for <code>java.time.LocalDate</code>.</p>
<pre><code class="language-scala">import java.time.{DayOfWeek, LocalDate}

object Euler019M extends EulerApp {
  override def execute(): Int = {
    val endDate = LocalDate.of(2000, 12, 31)
    var currentDate = LocalDate.of(1901, 1, 1)
    var sundays = 0

    while (currentDate.isBefore(endDate)) {
      if (currentDate.getDayOfMonth == 1 &amp;&amp; currentDate.getDayOfWeek == DayOfWeek.SUNDAY) sundays += 1
      currentDate = currentDate.plusDays(1)
    }

    sundays
  }
}
</code></pre>
<p>Easier, cleaner, better. But in this case, most of the information present in the problem description is not used.
We don’t need to check if the year is leap or how many days are in a month. In any project using the standard library
would be obviously the way to go, but since we’re just practicing, it makes sense to try to attempt doing it ourselves.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="factorial-digit-sum"><a class="header" href="#factorial-digit-sum">Factorial Digit Sum</a></h1>
<p>\(n!\) means \(n \times (n - 1) \times … \times 3 \times 2 \times 1\).</p>
<p>For example, \(10! = 10\times 9 \times … \times 3 \times 2 \times 1 = 3628800\),
and the sum of the digits in the number \(10!\) is \(3 + 6 + 2 + 8 + 8 + 0 + 0 = 27\).</p>
<p>Find the sum of the digits in the number \(100!\).</p>
<h2 id="solution-19"><a class="header" href="#solution-19">Solution</a></h2>
<p>Thanks to Scala’s extensive standard library, we can represent the factorial in question as a regular
<code>BigInt</code>. It even has a convenient <code>.factorial</code> method.</p>
<p>Once we have the result of \(100!\), we can recursively read it, digit by digit, using the modulo division.</p>
<pre><code class="language-scala">import EulerHelper.*

import scala.annotation.tailrec

object Euler020 extends EulerApp {
  override def execute(): Any = {
    sumDigits(BigInt(100).factorial)
  }

  @tailrec
  private def sumDigits(n: BigInt, result: BigInt = 0): BigInt =
    if (n == 0) result
    else sumDigits(n / 10, result + n % 10)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="amicable-numbers"><a class="header" href="#amicable-numbers">Amicable Numbers</a></h1>
<p>Let \(d(n)\) be defined as the sum of proper divisors of \(n\) (numbers less than \(n\) which divide evenly
into \(n\). If \(d(a) = b\) and \(d(b) = a\), where \(a \neq b\), then \(a\) and \(b\) are an
amicable pair and each of \(a\) and \(b\) are called amicable numbers.</p>
<p>For example, the proper divisors of \(220\) are \(1,2,4,5,10,11,20,22,44,55\) and \(110\); therefore
\(d(220) = 284\). The proper divisors of \(284\) are \(1,2,4,71\) and \(142\); so \(d(284) = 220\).</p>
<p>Evaluate the sum of all the amicable numbers under \(10000\).</p>
<h2 id="lets-make-it-easier-3"><a class="header" href="#lets-make-it-easier-3">Let’s make it easier</a></h2>
<p>First thing to crack is how to calculate the divisors efficiently. Should we use prime factors? Perhaps, but as a
rule of thumb I always start with a simpler approach and move on to a more advanced one if the simple one is not
good enough.</p>
<p>If we wanted to find all the divisors of 220, how many numbers do we need to check? We can check from \(2\)
to \(110 (220 / 2))), but there’s a better way. Logically, if \(220\) is divisible by \(2\) and we get 110 as
a result, then it must be divisible by \(110\) as well. That’s a strong hint that we don’t need to check all the
numbers.</p>
<p>How many do we need to check? \(220\) isn’t a great example, so, let’s switch to \(100\), this will be more
intuitive. We know that it’s divisible by \(2\), the result of the division is \(50\). We have our first two
divisors. Next divisor is \(4\), the result is \(25\). Now we have four divisors: \(2, 4, 25, 50).</p>
<p>Next divisor is \(5\) and \(20\), because \(100 ÷ 5 = 20\). Another one is \(10\). Now that’s a pretty
interesting coincidence, that \(100 ÷ 10\) is also \(10\). We no longer have two numbers, just one. Something
to keep in mind when designing the algorithm.</p>
<p>Do we need to check further? Let’s pretend that 100 is divisible by \(11\). Obviously it isn’t, but let’s just
pretend for a while! In order to get the second number we’d divide \(100\) by \(11\) and it would be a number
smaller than \(10\). Which means that it’s a number that we should’ve already found before. The conclusion is, then,
that we don’t need to check anything past \(10\).</p>
<p>\(10\) is a square root of \(100\). As long as we keep adding two divisors at once, there’s no need to go past the
square root.</p>
<h2 id="solution-20"><a class="header" href="#solution-20">Solution</a></h2>
<p>Let’s try to write a function that calculates the divisors based on our previous findings. We also need to keep in mind
that every number is divisible by one, so we can start the iteration from \(2\).</p>
<pre><code class="language-scala">private def divisors(n: Int): Seq[Int] = 1 +: (2 to Math.sqrt(n).toInt).flatMap {
  case i if n % i == 0 =&gt; if (i != n / i) List(i, n / i) else List(i)
  case _ =&gt; List()
}
</code></pre>
<p>The code above does exactly what was described before. If <code>i</code> is a divisor, <code>n % i == 0</code>, then we’ve found two of them,
the: <code>List(i, n / i)</code>.</p>
<p>We’re not very close to the complete solution. All we have to do left is to calculate the sum of divisors of
numbers under \(10000\), then use that information to find the amicable numbers.</p>
<pre><code class="language-scala">object Euler021 extends EulerApp {
  override def execute(): Any = {
    val divisorSums = (0 to 10000).map(n =&gt; divisors(n).sum)
    divisorSums.zipWithIndex.collect {
      case (sum, index) if sum &lt; 10000 &amp;&amp; sum != index &amp;&amp; index == divisorSums(sum) =&gt;
        index
    }.sum
  }

  private def divisors(n: Int): Seq[Int] = 1 +: (2 to Math.sqrt(n).toInt).flatMap {
    case i if n % i == 0 =&gt; if (i != n / i) List(i, n / i) else List(i)
    case _ =&gt; List()
  }
}
</code></pre>
<p>In my solution, I’m storing the sum of divisors in a <code>Seq</code>, where <code>Seq(1)</code> represents the sum of divisors of <code>1</code>.</p>
<p>If you think about the signature of <code>divisors(n: Int): Seq[Int]</code>, we don’t need to return the <code>Seq[Int]</code> at all here.
We’re interested in the sum, so <code>Int</code> is enough. But with sums alone, debugging would get much more difficult if you
made a mistake in calculating the divisors. It’s up to you though.</p>
<p>In the end, the current solution is pretty fast, so we can stop here and keep it as it is.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
