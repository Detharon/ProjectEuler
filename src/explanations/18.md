# Maximum Path Sum I

By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total
from top to bottom is \\(23\\).

<p style="text-align: center; font-family: monospace;">
    <span style="color: #a00;"><b>3</b></span><br>
    <span style="color: #a00;"><b>7</b></span> 4<br>
    2 <span style="color: #a00;"><b>4</b></span> 6<br>
    8 5 <span style="color: #a00;"><b>9</b></span> 3
</p>

That is, \\(3 + 7 + 4 + 9 = 23\\).

Find the maximum total from top to bottom of the triangle below:

<p style="text-align: center; font-family: monospace;">75<br>
95 64<br>
17 47 82<br>
18 35 87 10<br>
20 04 82 47 65<br>
19 01 23 75 03 34<br>
88 02 77 73 07 63 67<br>
99 65 04 28 06 16 70 92<br>
41 41 26 56 83 40 80 70 33<br>
41 48 72 33 47 32 37 16 94 29<br>
53 71 44 65 25 43 91 52 97 51 14<br>
70 11 33 28 77 73 17 78 39 68 17 57<br>
91 71 52 38 17 14 91 43 58 50 27 29 48<br>
63 66 04 68 89 53 67 30 73 16 69 87 40 31<br>
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23</p>

**NOTE**: As there are only \\(16384\\) routes, it is possible to solve this problem by trying every route.
However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute
force, and requires a clever method! ;o)

## Let's make it easier

We could indeed try to brute-force it, but I did not come up with any elegant brute-force in terms of implementation, so
I've decided to instead think about solving this problem the 'intended way'. As usual, let's think about a nice
algorithm that will save us from the necessity of checking all these possibilities. 
The small triangle will be perfect to plan it.

<p style="text-align: center; font-family: monospace;">3<br>
7 4<br>
2 4 6<br>
8 5 9 3<br>
</p>

Instead of plotting a route from the top, we could try to do it from the bottom. Can we do something with the last row?
Not really. We can't take the maximum since we don't know what's ahead of us, exactly as if we started from the top.

Moving to the row before last, that is, \\(2 4 6\\), we notice that each of those numbers have exactly two
children-numbers. For \\(2\\), that will be \\(8\\) and \\(5\\), for 4, it is \\(5\\) and \\(9\\), and so on.
If our question was to find the best path for those small sub-problems, with 3-number triangles, then naturally we'd
simply pick the bigger children. We can then add it to the parent. That's how the triangle now looks like:

<p style="text-align: center; font-family: monospace;">3<br>
7 4<br>
10 13 15<br>
</p>

We can do the same folding to the next row. Just need to pick the "bigger" children. Eventually we'll end up with that:

<p style="text-align: center; font-family: monospace;">3<br>
20 19<br>
</p>

And then we fold it once again, leaving us with a single value: \\(23\\). That's the maximum path sum.

## Solution

For a big triangle, the algorithm remains exactly the same. A natural way to implement it is to mutate the arrays that
represent the subsequent rows.

```scala
{{#include ../main/scala/Euler018M.scala}}
```

Very straightforward to implement, as it closely follows what we did on paper with the small triangle, but
unfortunately it mutates both the `dataArray` and the `rowIndex`.

For an immutable solution, we need to fold our triangle from the bottom. We can represent it as a
`List[List[Int]]` and reverse it so we start from the end.

```scala
val reversedData = prepareData().reverse
reversedData.tail.foldLeft(reversedData.head) { case (previousRow, currentRow) => ... }
```

This part starts from the second row (`.tail`), while the first one goes into the accumulator. Since we always have two
rows available, all we need to do is pick the bigger child and build the next accumulator, which will be our
new `previousRow`. Hereâ€™s the complete solution:

```scala
{{#include ../main/scala/Euler018.scala}}
```

That's it! Very concise, fully functional and with a similar run time.
