# Special Pythagorean Triplet

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

\\(a^2 + b^2 = c^2\\)

For example \\(3^2 + 4^2 = 9 + 16 = 25 = 5^2\\).

There exists exactly one Pythagorean triplet for which a + b + c = 1000.

Find the product abc.

## Solution

The numbers are low enough for a naive approach, so let's use it, while keeping the code nice and clean.

We need to check all combinations of a, b, c for which a + b + c = 1000 and find those that form a
Pythagorean triplet.

This naive algorithm starts from the highest possible 'c', keeps the sum of parameters at 1000, while gradually
incrementing 'b' and decrementing 'c' until this it's possible. This condition (b == c - 2 || b == c - 1) indicates
that the next triangle can't be created this way, so we need to increase the 'a' instead, while resetting the other
two parameters: 'b' to the lowest possible one, 'c' to whatever will give a sum of 1000.

It uses a LazyList which does keeps all the previous elements in memory. That's not something we need, but it makes
the code pretty concise. Let's also try a mutable approach.

```scala
{{#include ../main/scala/Euler009.scala}}
```

## Mutable solution

This time let's aim for maximum efficiency. Even though the idiomatic solution found the solution pretty fast
on my machine, the optimized one is about 10 to 15 times faster, even though they share the same algorithm.

It's also more concise. It looks rather enigmatic, which is the usual pitfalls for the optimized solutions, but
in this case the difference in performance was quite substantial.

```scala
{{#include ../main/scala/Euler009M.scala}}
```

