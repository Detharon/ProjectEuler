# Largest Product in a Series

The four adjacent digits in the 1000-digit number that have the greatest product are

\\(9 × 9 × 8 × 9 = 5832\\)

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

## Solution

The number might look daunting, but for any algorithm it's small enough that we don't need to optimize it much. 
This is the shortest solution (code-wise), but also the least efficient. We split the string into 13-element sliding windows,
then calculate the product of the digits in each window. 

Once we have the list of products, we simply take the maximum. Easy-peasy.
Could you explain why this solution is inefficient and what could significantly improve it, even at the cost of no
longer being functional?

```scala
{{#include ../main/scala/Euler008.scala}}
```

## Mutable solution

In the earlier approach, the sliding windows were completely independent of one another, which made it immutable, but
as I've also mentioned -- pretty inefficient.

By calculating the product of 13 elements, we were performing 11 redundant multiplications in each neighboring window.

Instead, we can maintain a running product — dividing by the digit that leaves the window
and multiplying by the new digit that enters it. The only catch here are the zeroes that break the computation chain.

While this approach is definitely faster, it’s also more error-prone and harder to read.
For example, consider the following line:

```scala
previous = buffer.remove(0).asDigit
```

It’s not immediately clear that `remove(0)` returns the element being removed.
Moreover, if the `.asDigit` call were omitted, the code would still compile and run,
but it would silently produce an incorrect result. For such a small task, the optimization is not worth
the effort, so treat it merely as a mental exercise.
